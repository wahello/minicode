#!/bin/bash

kc=""
image=xo
port=""
timeout=60
user=root
#passwd=root
idx=0
since=""
amount=""
kwd=""
list=0
kind="pod"
context=""
selector=""
args=""
chroot=""
localrun=0
savepath=""
vol=""

mandatory=()

function usage() {
  echo '
**USAGE**:
  kude <command> [<options>] [<object>]

**COMMANDS**:
  hp,help                  打印命令帮助
  print                    打印脚本文件内容
  git                      git运行git命令
  g,go                     运行go命令
  lg,lgo                   Linux环境下禁用CGO的go命令
  h,helm                   运行helm命令
  d,docker                 运行docker命令
  dc,dkc,docker-compose    运行docker-compose命令
  k,kube,kubectl           运行kubectl命令
  kk                       运行kubectl kustomize命令
  km,kustomize             运行kustomize命令
  ec,edc,etcdctl           运行etcdctl命令
  td,tdp,tcpdump           运行tcpdump抓包命令
  ts,tsk,tshark            运行tshark抓包命令(wireshark)
  it,iptable,iptables      运行iptables命令
  nm,nmap                  运行nmap命令
  ps,portstatus            运行端口检测命令
  n,net                    运行网络相关命令          
  ct,ssl,cred              加密凭证操作
  sp,sample                输出模板示例
  c,cmd                    运行linux命令
  scp                      分发本机文件
  gi                       git一键提交并上传
  pq,promq                 prometheus查询api
  ghp,ghelp                查看go命令帮助
  dhp,dhelp                查看docker命令帮助
  khp,khelp                查看kubectl命令帮助
  dr,drun                  运行容器
  drt,dtmp                 运行临时容器
  dat,dattach              attach到目标容器
  dx,dbg                   运行共享目标容器命名空间的镜像(调试)
  dsa,dstart               启动docker容器
  dsp,dstop                停止docker容器
  de,dexe,dexec            在容器中执行命令
  die,diexe,diexec         在容器中交互式执行命令
  dcp                      在本地和容器之间复制文件
  dtp,dtop                 查看容器中运行的进程
  dlg,dlog                 查看容器日志
  dlf,dlogf                实时查看容器日志
  dst,dstat,dstats         监控docker容器
  dq,dsearch               搜索镜像仓库
  db,dbd                   构建docker镜像
  dt,dtg,dtag              为镜像打标签
  dps,dlist                查看容器列表
  dm,dim,dimg              查看镜像列表
  di,din,dinsp             查看容器配置信息
  dmi,dmin,dminsp          查看镜像配置信息
  dn,dnet                  查看docker网络列表
  dv,dvol                  查看docker卷列表
  dd,drm                   删除容器
  do,drmi                  删除镜像
  dh,dhi,dhist             查看镜像构建历史
  ds,dput,dpush            推送镜像
  dl,dget,dpull            拉取镜像
  dpa,daddr                查看容器网络信息
  dpe,denv                 查看容器环境变量
  dpc,dcmd                 查看容器运行命令
  dpp,dport                查看容器端口映射
  dpm,dmnt                 查看容器卷挂载
  dcc                      删除所有已退出的容器
  dic                      删除所有未使用的镜像
  dvc                      删除所有未使用的容器卷
  dnc                      删除所有未使用的网络
  cf,cfind                 查找当前目录下包含指定关键字的文件
  df,dfind                 查找容器配置中包含指定关键字的容器
  kf,kfind                 查找资源中包含指定关键字的资源
  cfg,config               查看kubeconfig配置
  exp,explain              查看k8s资源描述
  expr,explainr            查看k8s资源及嵌套资源描述
  dry,dryrun               模拟执行kubectl命令
  eg,etcdget               通过etcdctl获取k8s的etcd数据
  egp,etcdgetp             通过etcdctl获取k8s的包括子目录在内的etcd数据
  ap,apl,apply             执行kubectl apply命令
  cr,crt,create            执行kubectl create命令
  r,run                    执行kubectl run命令
  b,rbac                   查看rbac结构图
  a,all                    查看指定命名空间下所有资源
  np,nodepod               列出运行在指定节点上的所有pod
  ni,nodeimg               列出指定节点上所有的镜像
  re,res                   列出k8s集群支持的所有资源
  ver,version              列出k8s集群的api版本
  ro,rollout               执行kubectl rollout命令
  au,auth                  执行kubectl auth命令
  pr,proxy                 开启kube apiserver本地代理
  tk,token                 获取serviceaccount的token
  li,lsimg                 列出k8s中所有容器使用的镜像
  lli,llimg                按行列出k8s中所有容器使用的镜像
  l,log                    查看pod内容器日志
  lf,logf                  实时查看容器日志
  i,insp,inspect           查看容器配置信息
  gt,get                   查看k8s资源信息
  s,desc,describe          查看k8s资源详细信息
  wt,watch                 监视指定k8s资源状态
  w,wide                   查看k8s资源更多信息
  wl,wlabel                查看k8s资源包括label在内的更多信息
  y,yaml                   以yaml格式查看k8s资源信息
  j,json                   以json格式查看k8s资源信息
  tp,top                   查看node或pod资源占用
  ed,edit                  编辑指定k8s资源
  p,patch                  为k8s资源打补丁
  rm,del,delete            删除指定k8s资源
  e,exe,exec               在pod中执行命令
  ie,iexe,iexec            在pod中交互式执行命令
  at,attach                加入pod的命名空间
  cp,copy                  在本地和pod之间复制文件
  pf,forward,port-forward  将本地端口映射到pod端口实现端口转发
  x,deb,debug              运行调试容器对pod进行调试

**OPTIONS**:
  -a [10m] log显示指定时间之后的日志
  -b [100] log显示条数
  -c [context] kubernetes连接上下文(可选)
  -d [savedir] rbac结构图保存目录(可选)
  -e [selector] k8s资源标签选择器
  -f [./kube/config] kubeonfig文件路径(可选)
  -i [0] 匹配pod内容器index(可选)
  -k [kind] k8s资源类型
  -m [xo] 自定义调试工具容器(可选)
  -n [default] 查询的k8s命名空间(可选)
  -o [host] 指定目标主机ip
  -p [22] 目标主机ssh端口(可选)
  -s [admin123] 目标主机ssh密码(可选)
  -t [60] 目标主机ssh连接超时时间(可选)
  -u [root] 目标主机ssh账号(可选)
  -w [kwd] 过滤关键字
  -j 配合cmd本机执行命令
  -l 列出满足条件的所有资源
  -r 调试容器中是否需要chroot到目标容器的文件系统
  -v 调试容器中是否需要挂载目标主机的docker.sock文件
  -h 使用说明
'
  if [ "$1" != "simple" ]; then
    echo '
**REFERENCES**:
# Linux: https://community.linuxmint.com/tutorial/view/244 https://man.linuxde.net/
# Docker: https://docs.docker.com/engine/reference/commandline/cli/
# Kubectl: https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/
# Etcd: https://etcd.io/docs/v3.4.0/op-guide/configuration/ https://etcd.io/docs/v3.4.0/dev-guide/interacting_v3/
# Helm: https://helm.sh/docs/helm/helm/

**EXAMPLES**:
# 直接执行docker或kubectl命令
kude d ps -a     #相当于docker ps -a
kude k get pod   #相当于kubectl get pod

# 查看docker或kubectl命令帮助
kude dhp run
kude khp get

# 进行docker镜像推送并删除临时tag
kude ds xshrim/xo foo.bar.com/xshrim

# 查看docker容器运行的命令
kude dpc nginx

# 删除包含指定关键字的容器
kude drm alp

# 查看镜像构建历史
kude dh xshrim/xo

# 远程到目标主机执行命令
kude cmd "ls /etc" 127.0.0.1 10.20.0.12-18
kude cmd -p 22 -s admin "ls /etc" 127.0.0.1

# 执行本机命令
kude cmd "scp test root@10.0.0.10:/root/test"

# 将本地文件分发到远程主机
kude scp "./foo:/root/bar" 10.20.0.12-18

# 查看主机网卡列表和详细信息
kude net ipa
kude net ipp UP
kude net ips 192.168

# 查看端口状态
kude ps 10.0.0.10 80

# 查看prometheus指标信息
kude pq metadata 127.0.0.1:9090 process_open_fds
kude pq md 127.0.0.1:9090 open instance=node-exporter

# 获取Kubernetes RBAC结构图
kude b u demouser
kude rbac -n kube-system rolebinding

# 查看kubeconfig配置
kude cfg

# 获取k8s集群容器使用的镜像
kude li -n default
kude lli

# 获取指定serviceaccount的token
kude tk
kude tk -n default

# 执行kubectl apply命令
kude ap pod.yaml

# 查找包含指定字符串的资源
kude kf -k sa token-ec9kd

# 开启kube-apiserver本地代理
kude pr 8443
kude pr 127.0.0.1:8443

# 查看pod容器日志
kude l nginx
kude lf nginx
kude lf -a 10 nginx
kude log -i 1 nginx

# 查看k8s资源详细信息
kude s nginx
kude desc -k deploy nginx

# 查找包含指定关键字的资源
kude -c acp-global -k sa -n default kf token-pfmd8

# 以yaml格式查看k8s资源信息
kude y nginx
kude yaml -k rs nginx

# 监视k8s资源状态
kude watch -k deploy nginx

# 为k8s资源打补丁
kude p -k deploy nginx "{\"spec\":{\"replicas\":2}}"

# 进入pod执行命令
kude e nginx -n default ls
kude ie nginx

# 在本地和pod之间复制文件
kude cp nginx :/foo ./foo
kude cp nginx -n default bar :/bar

# 将本地端口映射到pod端口实现端口转发
kude pf nginx 8000:80
kude -c minikube pf nginx -n default 8000:80

# 运行调试容器对pod内的指定容器进行调试
kude x nginx
kude debug -n xshrim -u root -p 22 -s admin123 -m netshoot nginx
'
  fi
}

function nethelp() {
echo '
**USAGE**:
  kude n <options> [<arguments>]

**COMMANDS**:
  h,hp,help                打印pq命令帮助
  arp                      查看arp列表
  pi                       ping主机或域名
  br                       执行网桥控制命令
  brs                      查看网桥列表
  brl                      查看bridge link
  brv                      查看bridge vlan
  brf                      查看bridge fdb
  brm                      查看bridge mdb
  ip                       执行ip命令
  ipr                      查看主机路由信息
  ipa                      查看主机网卡列表
  ipp                      查看主机物理网卡列表
  ips                      查看指定网卡详细信息
  tr                       执行mtr/traceroute命令
  ss                       查看主机网络统计信息(netstat,ss)
  nl                       域名解析
  nm                       执行nmap命令
  td                       执行tcpdump命令
  ts                       执行tshark命令
  it                       执行iptables命令
  ps                       查看端口状态
'
}

function nmaphelp() {
  echo '
[nmap选项]:
-iL: 指定输入文件, 可用于指定扫描的目标
-iR: 选择随机目标
–exclude: 排除主机, 即扫描的时候越过该主机
–excludefile: 通过黑名单文件指定排除的主机
-sL: 显示扫描主机的列表
-sn: 使用ping进行扫描
-Pn: 不进行主机发现, 直接进行深层扫描, 使用此命令时, nmap认为主机在线
-PS: 端口列表用,隔开[tcp80 syn 扫描]
-PA: 端口列表用,隔开ack扫描【默认扫描端口1-1024】
-PU: 端口列表用,隔开[udp高端口扫描 穿越只过滤tcp的防火墙]
-PE: 通过ICMP Echo扫描简单来说是通过向目标发送ICMP Echo数据包来探测目标主机是否存活, 但由于许多主机的防火墙会禁止这些报文, 所以仅仅ICMP扫描通常是不够的
-PP: 通过ICMP time stamp时间戳扫描在大多数防火墙配置不当时可能会得到回复, 可以以此方式来判断目标主机是否存活。倘若目标主机在线, 该命令还会探测其开放的端口以及运行的服务
-PM: 通过ICMP address maskPing地址掩码扫描会试图用备选的ICMP等级Ping指定主机, 通常有不错的穿透防火墙的效果
-PO: 进行一个基于指定的IP协议的ping
-n/-R: 选择是否进行dns解析
–dns-servers: 明确使用的DNS服务器
-system-dns: 使用主机nmap运行主机的dns
–traceroute: 跟踪扫描主机的网络路线
-sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans, 指定nmap的扫描方式, 默认为sT
-sU: 使用UDP协议进行扫描
-sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态
–scanflags: 定制TCP包的flags
-sI: 指定使用idle scan方式来扫描目标主机（前提需要找到合适的zombie host）
-sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况
-sO: 使用IP protocol 扫描确定目标机支持的协议类型
-b: 使用FTP bounce scan扫描方式
-p: Only scan specified ports
–exclude-ports: 排除指定端口不作扫描
-F: 快速模式, 仅扫描TOP 100的端口
-r: 不进行端口随机打乱的操作（如无该参数, nmap会将要扫描的端口以随机顺序方式扫描, 以让nmap的扫描不易被对方防火墙检测到）
–top-ports: 扫描开放概率最高的number个端口（nmap的作者曾经做过大规模地互联网扫描, 以此统计出网络上各种端口可能开放的概率
–port-ratio: 扫描指定频率以上的端口。与上述–top-ports类似, 这里以概率作为参数, 让概率大于–port-ratio的端口才被扫描
-sV: 指定让Nmap进行版本侦测
–version-intensity: 指定版本侦测强度（0-9）, 默认为7, 数值越高, 探测出的服务越准确, 但是运行时间会比较长
–version-light: 指定使用轻量侦测方式 (intensity 2)
–version-all: 尝试使用所有的probes进行侦测 (intensity 9)
–version-trace: 显示出详细的版本侦测过程信息
-sC: 指定script脚本为默认值
–script: 使用某个或某类脚本进行扫描, 支持通配符描述
–script-args: 为脚本提供默认参数
–script-args-file: 使用文件来为脚本提供参数
–script-trace: 显示脚本执行过程中发送与接收的数据
–script-updatedb: 更新脚本数据库, 每次更新脚本后
–script-help: 显示脚本的帮助信息, 其中部分可以逗号分隔的文件或脚本类别
-O: 指定Nmap进行OS侦测
–osscan-limit: 限制Nmap只对确定的主机的进行OS探测（至少需确知该主机分别有一个open和closed的端口）
–osscan-guess: 大胆猜测对方的主机的系统类型。由此准确性会下降不少, 但会尽可能多为用户提供潜在的操作系统
-T<0-5>: 扫描效率, 越高越快
–min-hostgroup/max-hostgroup: 平行的主机扫描组的大小
–min-parallelism/max-parallelism: 并行探测
–min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout: 指定每轮探测的时间
–max-retries: 扫描探测的上限次数设定
–host-timeout: 设置timeout时间
–scan-delay/–max-scan-delay: 调整两次探测之间的延迟
–min-rate: 每秒发送数据包不少于次
–max-rate: 每秒发送数据包不多于次
-f; --mtu: 指定使用分片、指定数据包的MTU.
-D: 用一组IP地址掩盖真实地址, 其中ME填入自己的IP地址
-S: 伪装成其他IP地址
-e: 使用特定的网络接口,指定网卡
-g/–source-port: 使用指定源端口
–proxies: 使用代理
–data: 给数据包添加指定数据
–data-string: 给数据包添加指定ASCII字符串
–data-length: 填充随机数据让数据包长度达到Num
–ip-options: 使用指定的IP选项来发送数据包。
–ttl: 设置time-to-live时间,没什么用
–spoof-mac: 伪装MAC地址, 伪装mac地址为指定值
–badsum: 使用错误的checksum来发送数据包（正常情况下, 该类数据包被抛弃, 如果收到回复, 说明回复来自防火墙或IDS/IPS）
-oN/-oX/-oS/-oG: 指定输出文件格式
-oA: 用生成以上格式的文件
-v: 这个选项使用两次, 会提供更详细的信息
-d: 提高或设置调试级别, 最高级别-d9, 输出更多的细节
–reason: 显示端口处于特定状态的原因
–open: 仅显示open的端口
–packet-trace: 显示所有的收发包
–iflist: 打印主机网络接口和路由
–append-output: 以追加的形式写入文件
–resume: 重新开始中断的扫描
–stylesheet: 指定xsl样式文件将xml转换为html
–webxml: 参考在线样式表
–no-stylesheet: 防止关联带有xml输出的样式表
-6: 启用IPv6扫描
-A: 启用OS检测, 版本检测, 脚本扫描和路由跟踪
–datadir: 指定自定义nmap数据文件路径
–send-eth/–send-ip: 使用原始以太网帧或ip数据包发送
–privileged: 假设用户具有完全特权
–unprivileged: 假设用户缺乏原始套接字特权
-V: 打印版本号
-h: 打印帮助摘要

[nmap示例]:
# 扫描并输出数据库信息
nmap -sS -p 1433,1434 -f --script ms-sql-info  -oG - -oX ms-sql.xml 110.42.96.0/24

# 爆破数据库
nmap -sT -p 1433,1434 -f --script ms-sql-brute -script-args userdb=sqluser.dic,passdb=sqlpass.dic -oG - -oX ms-sql-test.xml 110.42.96.0/24

# 获取远程主机的系统类型及开放端口
nmap -sS -P0 -sV -O 110.42.96.0

# 列出开放了指定端口的主机列表
nmap -sT -p 80 -oG – 192.168.1.* | grep open

# 在网络寻找所有在线主机
nmap -sP 192.168.0.*
nmap -sP 192.168.0.0/24

# Ping指定范围内的IP地址
nmap -sP 192.168.1.100-254

# 在某段子网上查找未占用的IP
nmap -T4 -sP 192.168.2.0/24 && egrep “00:00:00:00:00:00″ /proc/net/arp

# 在局域网上扫找Conficker蠕虫病毒
nmap -PN -T4 -p139,445 -n -v –script=smb-check-vulns –script-args safe=1 192.168.0.1-254

# 扫描网络上的恶意接入点rogue APs
nmap -A -p1-85,113,443,8080-8100 -T4 –min-hostgroup 50 –max-rtt-timeout2000 –initial-rtt-timeout 300 –max-retries 3 –host-timeout 20m–max-scan-delay 1000 -oA wapscan 10.0.0.0/8

# 使用诱饵扫描方法来扫描主机端口
nmap -sS 192.168.0.10 -D 192.168.0.2

# 为一个子网列出反向DNS记录
nmap -R -sL 209.85.229.99/27 | awk "{if($3=="not")print"("$2") no PTR";else print$3" is "$2}" | grep "("

# 显示网络上共有多少台Linux及Win设备
nmap -F -O 192.168.0.1-255 | grep "Running: " > /tmp/os; echo "$(cat /tmp/os | grep Linux \| wc -l) Linux device(s)"; echo "$(cat /tmp/os | grep Windows | wc -l) Window(s) device"

# 探测Web应用错误代码
nmap -p80,443 --script http-errors targetWebsite.com

# 爆破子域
nmap -p80,443 --script dns-brute targetWebsite.com
nmap -p80,443 --script dns-brute --script-args dns-brute.threads=25,dns-brute.hostlist=/root/Desktop/custom-subdomain-wordlist.txt targetWebsite.com

# 爬取Web应用
nmap -vv -p80,443 --script http-errors --script-args "httpspider.url=/docs/,httpspider.maxpagecount=3,httpspider.maxdepth=1" targetwebsite.com

# 探测Web应用防火墙以及防火墙指纹检测
nmap -p80,443 --script http-waf-detect --script-args "http-waf-detect.aggro,http-waf-detect.detectBodyChanges" targetWebsite.com
nmap -p80,443 --script http-waf-fingerprint targetWebsite.comStarting 
nmap -p80,443 --script http-waf-fingerprint --script-args http-waf-fingerprint.intensive=1 targetWebsiteStarting

# 提取图片嵌入式信息EXIF
nmap -p80,443 --script http-exif-spider targetWebsite.com
nmap -p80,443 --script http-exif-spider --script-args "http.max-cache-size=99999999" targetWebsite.com
  '
}

function promqhelp() {
  echo '
**USAGE**:
  kude pq <options> [<arguments>]

**COMMANDS**:
  h,hp,help                打印pq命令帮助
  i,m,md,info,metadata     打印指标元数据信息
  s,inst,series,instance   打印series信息
  l,v,lv,label,value       打印label及其value数据
  t,tg,target              打印target数据
  r,rl,rule                打印rule数据
  a,al,alert               打印alert数据
  am,alertmanager          打印alertmanager配置
  v,status                 打印prometheus状态信息
  q,query                  使用promql进行查询
  qr,rq,query_range        使用promql进行范围查询
  '
}

function sslhelp() {
  echo '
**USAGE**:
  kude ssl <options> [<arguments>]

**COMMANDS**:
  h,hp,help                打印ssl命令帮助
  gen,generate             生成整套openssl-x509凭证
  out,show                 打印openssl-x509证书或密钥信息
  mat,match                检查证书与密钥是否匹配
  ver,verify               检查证书与签发者证书是否匹配
  get,fetch                获取url的证书
  sver,sverify             检查url证书与域名是否匹配
  '
}

function gensslhelp() {
  echo ' ================================================================ '
  echo ' --ssl-domain: 生成ssl证书需要的主域名，如不指定则默认为localhost，如果是ip访问服务，则可忽略；'
  echo ' --ssl-trusted-ip: 一般ssl证书只信任域名的访问请求，有时候需要使用ip去访问server，那么需要给ssl证书添加扩展IP，多个IP用逗号隔开；'
  echo ' --ssl-trusted-domain: 如果想多个域名访问，则添加扩展域名（SSL_TRUSTED_DOMAIN）,多个扩展域名用逗号隔开；'
  echo ' --ssl-size: ssl加密位数，默认2048；'
  echo ' --ssl-date: ssl有效期，默认10年；'
  echo ' --ca-date: ca有效期，默认10年；'
  echo ' --ssl-cn: 国家代码(2个字母的代号),默认CN;'
  echo ' --ca-reuse: 是否复用指定CA私钥和证书;'
  echo ' --ca-key: 指定复用的CA私钥路径;'
  echo ' --ca-cert: 指定复用的CA证书路径;'
  echo ' 使用示例:'
  echo ' kude ssl gen --ssl-domain=www.test.com --ssl-trusted-domain=*.test1.com,www.test2.com \ '
  echo ' --ssl-trusted-ip=1.1.1.1,2.2.2.2,3.3.3.3 --ssl-size=2048 --ssl-date=3650'
  echo ' or'
  echo ' kude ssl gen --ssl-domain=www.test.com --ssl-trusted-domain=*.test1.com,www.test2.com \ '
  echo ' --ssl-trusted-ip=1.1.1.1,2.2.2.2 --ssl-size=2048 --ssl-date=3650 --ca-reuse=true ca-key=cakey.pem ca-cert=cacerts.pem'
  echo ' ================================================================'
}

function tcpdumphelp() {
  echo '
[tcpdump选项]:
-A: 以ASCII文本显示抓包内容
-D: 列出所有网络接口
-F: 从文件中读取抓包的表达式
-P: 指定要抓取的包是流入还是流出的包
-X: 以16进制显示数据包承载的数据内容
-l: 使标准输出变为缓冲行形式
-c: 抓包次数
-n: 禁用域名解析
-s: 设置每个数据包的大小
-i: 指定监听的网络接口
-r: 从指定的文件中读取包
-w: 输出信息保存到指定文件
-a: 将网络地址和广播地址转变成名字
-d: 将匹配信息包的代码以人们能够理解的汇编格式给出
-e: 在输出行打印出数据链路层的头部信息
-f: 将外部的 Internet 地址以数字的形式打印出来
-t: 在输出的每一行不打印时间戳
-q: 快速打印简短输出
-v: 输出稍微详细的报文信息
-nn: 直接以IP及Port显示而非主机名与服务名称
-vv: 输出更详细报文信息
-vvv: 尝试解析应用层协议输出更详细报文信息

[tcpdump关键字]:
方向关键字: src, dst
类型关键字: host, net, port, portrange
协议关键字: ip, ip6, arp, tcp, udp, icmp, ether
协议内容过滤: proto[x:y]: 过滤协议从x字节开始的y字节数
逻辑运算符: ! not, && and, || or
tcp标记: tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg, tcp-ece, tcp-cwr
计算字符串二进制: list(map(hex, [ord(x) for x in "GET "]))

[tcpdump示例]:
# 从所有网卡抓取数据包
tcpdump -i any

# 抓取整个网段的数据包
tcpdump net 192.168.1.0/24

# 抓取包含172.16.1.122的数据包  
tcpdump -i eth0 -vnn host 172.16.1.122  

# 抓取包含172.16.1.0/24网段的数据包  
tcpdump -i eth0 -vnn net 172.16.1.0/24  

# 抓取包含端口22-50的数据包  
tcpdump -i eth0 -vnn portrange 22-50

# 抓取udp协议的数据包  
tcpdump -i eth0 -vnn  udp

# 抓取icmp协议的数据包  
tcpdump -i eth0 -vnn icmp  

# 抓取arp协议的数据包  
tcpdump -i eth0 -vnn arp  

# 抓取ip协议的数据包  
tcpdump -i eth0 -vnn ip

# 抓取目的ip是10网段的数据包
tcpdump -i any -nn "ip[16] == 10"

# 抓取目的ip范围是 192.168.1.10 ~ 192.168.1.100网段的数据包
tcpdump -i any -nn "ip[16] == 192 and ip[17] == 168 and ip[18] == 1 and ip[19] > 9 and ip[19] < 101"

# 抓取源ip是172.16.1.122数据包 
tcpdump -i eth0 -vnn src host 172.16.1.122  

# 抓取目的ip是172.16.1.122数据包  
tcpdump -i eth0 -vnn dst host 172.16.1.122  

# 抓取源端口是22的数据包  
tcpdump -i eth0 -vnn src port 22  

# 抓取源ip是172.16.1.253且目的ip是22的数据包  
tcpdump -i eth0 -vnn src host 172.16.1.253 and dst port 22  

# 抓取源ip是172.16.1.122或者包含端口是22的数据包  
tcpdump -i eth0 -vnn src host 172.16.1.122 or port 22  

# 抓取源ip是172.16.1.122且端口不是22的数据包  
tcpdump -i eth0 -vnn src host 172.16.1.122 and not port 22  

# 抓取源ip是172.16.1.59且目的端口是22，或源ip是172.16.1.68且目的端口是80的数据包
tcpdump -i  eth0 -vnn "src host 172.16.1.59 and dst port 22" or  " src host 172.16.1.68 and dst port 80 "

# 把抓取的数据包记录存到/tmp/fill.cap文件中，当抓取100个数据包后就退出程序 
tcpdump –i eth0 -vnn -w  /tmp/fill.cap -c 100  

# 从/tmp/fill.cap记录中读取tcp协议的数据包  
tcpdump –i eth0 -vnn -r  /tmp/fill.cap tcp  

# 从/tmp/fill记录中读取包含172.16.1.58的数据包  
tcpdump –i eth0 -vnn -r  /tmp/fill.cap host  172.16.1.58

# 抓取所有经过eth0的目的地址是10.10.1.254或10.10.1.200端口是80的TCP数据包
# tcpdump -i eth0 "((tcp) and (port 80) and ((dst host 10.10.1.254) or (dst host 10.10.1.200)))"

# 抓取目标域名是foo.bar的数据包
tcpdump -i eth0 -vn dst host foo.bar

# 抓取域名为foo.bar且非80和25端口的数据包
tcpdump -i eth0 host foo.bar and not port 80 and not port 25

# 抓取http get数据包
tcpdump -i eth0 "tcp[(tcp[12]>>2):4] = 0x47455420"
tcpdump -i eth0 "tcp[20:2]=0x4745 or tcp[20:2]=0x4854"

# 抓取http get数据包
tcpdump -s 0 -A "tcp dst port 80 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420"

# 抓取https post数据包
tcpdump -s 0 -A "tcp dst port 443 and (tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504f5354)"

# 抓取http和https的get和post数据包
tcpdump -i any -s 0 -A "tcp dst port 80 or tcp dst port 443 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420 or tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504F5354" and host 192.168.10.1

# 抓取到指定端口http get数据包并输出最详细信息
tcpdump -i any -s 0 -nnvvvXS -A "tcp dst port 8000 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420"

# 抓取ssh返回数据包
tcpdump -i eth0 "tcp[(tcp[12]>>2):4] = 0x5353482D"

# 抓取http响应数据包
tcpdump -i eth0 "tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x48545450 && tcp[((tcp[12:1] & 0xf0) >> 2) + 4:2] = 0x2f31 && tcp[((tcp[12:1] & 0xf0) >> 2) + 6:1] = 0x2e"

# 抓取dns请求数据包
tcpdump -i eth0 udp dst port 53

# 抓取tcp协议数据包
tcpdump -i eth0 tcp

# 抓取大于600字节的数据包
tcpdump -i eth0 "ip[2:2] > 600"

# 抓取源端口大于1024的数据包
tcpdump -i eth0 "tcp[0:2] > 1024"

# 抓取tcp syn/ack数据包
tcpdump -i eth0 "tcp[tcpflags] & (tcp-syn|tcp-ack) != 0"

# 获取http请求的URL
tcpdump -i any -s 0 -v -n -l | egrep -i "POST / | GET / | Host:"

# 获取http请求密码
tcpdump -i any -s 0 -A -n -l | egrep -i "POST /|pwd=|passwd=|password=|Host:"

# 获取http请求 cookie
tcpdump -i any -nn -A -s0 -l | egrep -i "Set-Cookie|Host:|Cookie:"

# 获取http请求user agent
tcpdump -vvAls0 | grep "User-Agent:"

# 计算抓取10000各syn数据包所使用的时间从而估算访问量
time tcpdump -nn -i eth0 "tcp[tcpflags] = tcp-syn" -c 10000 > /dev/null

# 保存10000个数据包过滤条件为443端口并解析来源IP
tcpdump -i any -nn -c 10000 port 443 > tcpdump.log
cat tcpdump.log | awk "{print $3}" | awk -F "." "{print $1"."$2"."$3"."$4}" | sort | uniq -c | sort -rn

# 后台滚动抓包
nohup tcpdump -i eth0 port 22 -s0 -G 3600 -Z root -w ssh22_%Y_%m%d_%H%M_%S.pcap &
'
}

function tsharkhelp() {
  echo '
[tshark选项]:
-i: 设置抓包的网络接口，不设置则默认为第一个非自环接口
-D: 列出当前存在的网络接口。在不了解OS所控制的网络设备时，一般先用“tshark -D”查看网络接口的编号以供-i参数使用
-f: 设定抓包过滤表达式（capture filter expression）。抓包过滤表达式的写法雷同于tcpdump，可参考tcpdump man page的有关部分
-s: 设置每个抓包的大小，默认为65535，多于这个大小的数据将不会被程序记入内存、写入文件。（这个参数相当于tcpdump的-s，tcpdump默认抓包的大小仅为68）
-p: 设置网络接口以非混合模式工作，即只关心和本机有关的流量
-B: 设置内核缓冲区大小，仅对windows有效
-y: 设置抓包的数据链路层协议，不设置则默认为-L找到的第一个协议，局域网一般是EN10MB等
-L: 列出本机支持的数据链路层协议，供-y参数使用
-c: 抓取的packet数，在处理一定数量的packet后，停止抓取，程序退出
-a: 设置tshark抓包停止向文件书写的条件，事实上是tshark在正常启动之后停止工作并返回的条件。条件写为test:value的形式，如“-a duration:5”表示tshark启动后在5秒内抓包然后停止；“-a filesize:10”表示tshark在输出文件达到10kB后停止；“-a files:n”表示tshark在写满n个文件后停止
-b: 设置ring buffer文件参数。ring buffer的文件名由-w参数决定。-b参数采用test:value的形式书写。“-b duration:5”表示每5秒写下一个ring buffer文件；“-b filesize:5”表示每达到5kB写下一个ring buffer文件；“-b files:7”表示ring buffer文件最多7个，周而复始地使用，如果这个参数不设定，tshark会将磁盘写满为止
-r: 设置tshark分析的输入文件。tshark既可以抓取分析即时的网络流量，又可以分析dump在文件中的数据。-r不能是命名管道和标准输入
-A: 使用RPCAP密码进行认证
-2: 执行两次分析
-R: 设置读取（显示）过滤表达式（read filter expression）。不符合此表达式的流量同样不会被写入文件
-Y: 使用读取过滤器的语法，在单次分析中可以代替-R选项;
-n: 禁止所有地址名字解析（默认为允许所有）
-N: 启用某一层的地址名字解析。“m”代表MAC层，“n”代表网络层，“t”代表传输层，“C”代表当前异步DNS查找。如果-n和-N参数同时存在，-n将被忽略。如果-n和-N参数都不写，则默认打开所有地址名字解析
-d: 将指定的数据按有关协议解包输出。如要将tcp 8888端口的流量按http解包，应该写为“-d tcp.port==8888,http”。注意选择子和解包协议之间不能留空格
-w: 设置raw数据的输出文件。这个参数不设置，tshark将会把解码结果输出到stdout。“-w-”表示把raw输出到stdout。如果要把解码结果输出到文件，使用重定向“>”而不要-w参数
-F: 设置输出raw数据的格式，默认为libpcap。“tshark -F”会列出所有支持的raw格式
-V: 设置将解码结果的细节输出，否则解码结果仅显示一个packet一行的summary
-O: 只显示此选项指定的协议的详细信息
-P: 即使将解码结果写入文件中，也打印包的概要信息
-E: 如果-T fields选项指定，使用-E来设置一些属性
-x: 设置在解码输出结果中，每个packet后面以HEX dump的方式显示具体数据
-T: 设置解码结果输出的格式，包括text,ps,psml和pdml，默认为text
-t: 设置解码结果的时间格式。“ad”表示带日期的绝对时间，“a”表示不带日期的绝对时间，“r”表示从第一个包到现在的相对时间，“d”表示两个相邻包之间的增量时间（delta）
-u: s|hms 格式化输出秒
-S: 在向raw文件输出的同时，将解码结果打印到控制台
-l: 在处理每个包时即时刷新输出
-X: 扩展项
-q: 设置安静的stdout输出（例如做统计时）
-z: 设置统计参数
-h: 显示命令行帮助
-v: 显示tshark的版本信息
-o: 重载选项

[tshark示例]:
# 实时打印当前http请求的url
tshark -s 512 -i eth0 -n -f "tcp dst port 80" -R "http.host and http.request.uri" -T fields -e http.host -e http.request.uri -l | tr -d "\t"

# 实时打印当前mysql查询语句
tshark -s 512 -i eth0 -n -f "tcp dst port 3306" -R "mysql.query" -T fields -e mysql.query

# 导出smpp协议header和value
tshark -r test.cap -R "(smpp.command_id==0x80000004) and (smpp.command_status==0x0)" -e smpp.message_id -e frame.time -T fields -E header=y >test.txt

# 统计http状态
tshark -n -q -z http,stat, -z http,tree

# 输出http协议的请求头，响应头，和响应数据
tshark -2 -r httpsession.pcap -R "http.request.line || http.file_data || http.response.line" -T fields -e http.request.line -e http.file_data -e http.response.line -E header=y

# 抓取500个包提取访问的网址
tshark -s 0 -i eth0 -n -f "tcp dst port 80" -R "http.host and http.request.uri" -T fields -e http.host -e http.request.uri -l -c 500

# 显示ssl data数据
tshark -n -t a -R ssl -T fields -e "ip.src" -e "ssl.app_data"

# 读取指定报文,按照ssl过滤显示内容
tshark -r temp.cap -R "ssl" -V -T text
tshark -r temp.cap -z "follow,tcp,ascii,13"

# 按照指定格式显示
tshark -r temp.cap -R ssl -Tfields -e "ip.src" -e tcp.srcport -e ip.dst -e tcp.dstport

# 输出数据
tshark -r vmx.cap -q -n -t ad -z follow,tcp,ascii,10.1.8.130:56087,10.195.4.41:446 | more

# 过滤包的时间和rtp.seq
tshark  -i eth0 -f "udp port 5004"  -T fields -e frame.time_epoch -e rtp.seq -o rtp.heuristic_rtp:true 1>test.txt

# 提取各协议数据部分
tshark -r H:/httpsession.pcap -q -n -t ad -z follow,tcp,ascii,71.6.167.142:27017,101.201.42.120:59381 | more

# 分析报文封装的协议
tshark -r httpsession.pcap -T fields -e frame.number -e frame.protocols -E header=y
  '
}

function iptableshelp() {
  echo '
[iptables选项]:
-t, --table table: 对指定的表 table 进行操作， table 必须是 raw， nat，filter，mangle 中的一个。如果不指定此选项，默认的是 filter 表
# 通用匹配: 源地址目标地址的匹配
-p: 指定要匹配的数据包协议类型
-s, --source [!] address[/mask]: 把指定的一个／一组地址作为源地址，按此规则进行过滤。当后面没有 mask 时，address 是一个地址，比如: 192.168.1.1；当 mask 指定时，可以表示一组范围内的地址，比如: 192.168.1.0/255.255.255.0
-d, --destination [!] address[/mask]: 地址格式同上，但这里是指定地址为目的地址，按此进行过滤
-i, --in-interface [!] <网络接口name>: 指定数据包的来自来自网络接口，比如最常见的 eth0 。注意: 它只对 INPUT，FORWARD，PREROUTING 这三个链起作用。如果没有指定此选项， 说明可以来自任何一个网络接口。同前面类似，"!" 表示取反
-o, --out-interface [!] <网络接口name>: 指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用
# 查看管理命令
-L, --list [chain]: 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则
# 规则管理命令
-A, --append chain rule-specification: 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定
-I, --insert chain [rulenum] rule-specification: 在链 chain 中的指定位置插入一条或多条规则。如果指定的规则号是1，则在链的头部插入。这也是默认的情况，如果没有指定规则号
-D, --delete chain rule-specification -D, --delete chain rulenum: 在指定的链 chain 中删除一个或多个指定规则
-R num: Replays替换/修改第几条规则
# 链管理命令（这都是立即生效的）
-P, --policy chain target: 为指定的链 chain 设置策略 target。注意，只有内置的链才允许有策略，用户自定义的是不允许的
-F, --flush [chain]: 清空指定链 chain 上面的所有规则。如果没有指定链，清空该表上所有链的所有规则
-N, --new-chain chain: 用指定的名字创建一个新的链
-X, --delete-chain [chain]: 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。如果没有指定链名，则会删除该表中所有非内置的链
-E, --rename-chain old-chain new-chain: 用指定的新名字去重命名指定的链。这并不会对链内部造成任何影响
-Z, --zero [chain]: 把指定链，或者表中的所有链上的所有计数器清零
-j, --jump target <指定目标>: 即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链
-h: 显示帮助信息

[iptables表]:
raw: 高级功能，如: 网址过滤
mangle: 数据包修改（QOS），用于实现服务质量
nat: 地址转换，用于网关路由器
filter: 包过滤，用于防火墙规则

[iptables链]:
INPUT: 处理输入数据包
OUTPUT: 处理输出数据包
FORWARD: 处理转发数据包
PREROUTING: 用于目标地址转换（DNAT）
POSTOUTING: 用于源地址转换（SNAT）

[iptables动作]:
ACCEPT: 接收数据包
DROP: 丢弃数据包
REDIRECT: 重定向、映射、透明代理
SNAT: 源地址转换
DNAT: 目标地址转换
MASQUERADE: IP伪装（NAT），用于ADSL
LOG: 日志记录

[iptables示例]:
# 清空当前的所有规则和计数
iptables -F  # 清空所有的防火墙规则
iptables -X  # 删除用户自定义的空链
iptables -Z  # 清空计数

# 配置允许ssh端口连接
iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT
# 22为你的ssh端口， -s 192.168.1.0/24表示允许这个网段的机器来连接，其它网段的ip地址是登陆不了你的机器的。 -j ACCEPT表示接受这样的请求

# 允许本地回环地址可以正常使用
iptables -A INPUT -i lo -j ACCEPT
# 本地圆环地址就是那个127.0.0.1，是本机上使用的,它进与出都设置为允许
iptables -A OUTPUT -o lo -j ACCEPT

# 设置默认的规则
iptables -P INPUT DROP # 配置默认的不让进
iptables -P FORWARD DROP # 默认的不允许转发
iptables -P OUTPUT ACCEPT # 默认的可以出去

# 配置白名单
iptables -A INPUT -p all -s 192.168.1.0/24 -j ACCEPT  # 允许机房内网机器可以访问
iptables -A INPUT -p all -s 192.168.140.0/24 -j ACCEPT  # 允许机房内网机器可以访问
iptables -A INPUT -p tcp -s 183.121.3.7 --dport 3380 -j ACCEPT # 允许183.121.3.7访问本机的3380端口

# 开启相应的服务端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 开启80端口，因为web对外都是这个端口
iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT # 允许被ping
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 已经建立的连接得让它进来

# 保存规则到配置文件中
cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak # 任何改动之前先备份，请保持这一优秀的习惯
iptables-save > /etc/sysconfig/iptables
cat /etc/sysconfig/iptables

# 列出已设置的规则
iptables -L [-t 表名] [链名]
iptables -L -t nat                  # 列出 nat 上面的所有规则
iptables -L -t nat  --line-numbers  # 规则带编号
iptables -L INPUT
iptables -L -nv  # 查看，这个列表看起来更详细

# 清除已有规则
iptables -F INPUT  # 清空指定链 INPUT 上面的所有规则
iptables -X INPUT  # 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。不指定则删除该表中所有非内置链
iptables -Z INPUT  # 把指定链，或者表中的所有链上的所有计数器清零。

# 删除已添加的规则
iptables -A INPUT -s 192.168.1.5 -j DROP # 添加一条规则
iptables -L -n --line-numbers # 列出带序号的规则
iptables -D INPUT 8  #删除INPUT里序号为8的规则

# 开放指定的端口
iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               #允许本地回环接口(即运行本机访问本机)
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    #允许已建立的或相关连的通行
iptables -A OUTPUT -j ACCEPT      # 允许所有本机向外的访问
iptables -A INPUT -p tcp --dport 22 -j ACCEPT    # 允许访问22端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT    # 允许访问80端口
iptables -A INPUT -p tcp --dport 21 -j ACCEPT    # 允许ftp服务的21端口
iptables -A INPUT -p tcp --dport 20 -j ACCEPT    # 允许FTP服务的20端口
iptables -A INPUT -j reject       # 禁止其他未允许的规则访问
iptables -A FORWARD -j REJECT     # 禁止其他未允许的规则访问

# 屏蔽端口
iptables -A INPUT -p tcp --dport 12345 -j DROP  # 屏蔽访问 12345 端口

# 屏蔽域名
iptables -A OUTPUT -m string --string \"foo.bar\" --algo bm --to 65535 -j DROP  # 屏蔽服务器内域名访问

# 屏蔽IP
iptables -A INPUT -p tcp -m tcp -s 192.168.0.8 -j DROP  # 屏蔽恶意主机（比如，192.168.0.8
iptables -I INPUT -s 123.45.6.7 -j DROP       # 屏蔽单个IP的命令
iptables -I INPUT -s 123.0.0.0/8 -j DROP      # 封整个段即从123.0.0.1到123.255.255.254的命令
iptables -I INPUT -s 124.45.0.0/16 -j DROP    # 封IP段即从123.45.0.1到123.45.255.254的命令
iptables -I INPUT -s 123.45.6.0/24 -j DROP    # 封IP段即从123.45.6.1到123.45.6.254的命令

# 指定数据包出去的网络接口
iptables -A FORWARD -o eth0  #只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用

# 查看已添加的规则
iptables -L -n -v

# 启动网络转发规则
iptables -t nat -A POSTROUTING -s 192.168.188.0/24 -j SNAT --to-source 210.14.67.127  #公网210.14.67.7让内网192.168.188.0/24上网

# 端口映射
iptables -t nat -A PREROUTING -d 210.14.67.127 -p tcp --dport 2222  -j DNAT --to-dest 192.168.188.115:22  #本机的2222端口映射到内网虚拟机的22端口

# 字符串匹配
iptables -A INPUT -p tcp -m string --algo kmp --string "test" -j REJECT --reject-with tcp-reset  # 终止所有带字符串test的TCP连接

# 阻止Windows蠕虫的攻击
iptables -I INPUT -j DROP -p tcp -s 0.0.0.0/0 -m string --algo kmp --string "cmd.exe"

# 防止SYN洪水攻击
iptables -A INPUT -p tcp --syn -m limit --limit 5/second -j ACCEPT
  '
}

function main() {
  if [ -z $1 ]; then
    usage simple
    exit 1
  elif [ $1 == "print" ]; then
    cat $(echo $0)
  elif [ $1 == "g" ] || [ $1 == "go" ]; then
    require go
    shift
    go $*
  elif [ $1 == "lg" ] || [ $1 == "lgo" ]; then
    require go
    shift
    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go $*
  elif [ $1 == "git" ]; then
    require git
    shift
    git $*
  elif [ $1 == "h" ] || [ $1 == "helm" ]; then
    require helm
    shift
    helm $*
  elif [ $1 == "kk" ]; then
    require kubectl
    shift
    kubectl kustomize $*
  elif [ $1 == "km" ] || [ $1 == "kustomize" ]; then
    require kustomize
    shift
    kustomize $*
  elif [ $1 == "ec" ] || [ $1 == "edc" ] || [ $1 == "etcdctl" ]; then
    require etcdctl
    shift
    etcdctl $*
  elif [ $1 == "td" ] || [ $1 == "tdp" ] || [ $1 == "tcpdump" ]; then
    shift
    if [ $1 == "h" ] || [ $1 == "hp" ]; then
      tcpdumphelp
    elif [ $1 == "help" ]; then
      require tcpdump
      tcpdump --help
    else
      require tcpdump
      tcpdump $*
    fi
  elif [ $1 == "ts" ] || [ $1 == "tsk" ] || [ $1 == "tshark" ]; then
    shift
    if [ $1 == "h" ] || [ $1 == "hp" ]; then
      tsharkhelp
    elif [ $1 == "help" ]; then
      require tshark
      tshark --help
    else
      require tshark
      tshark $*
    fi
  elif [ $1 == "nm" ] || [ $1 == "nmap" ]; then
    shift
    if [ $1 == "h" ] || [ $1 == "hp" ]; then
        nmaphelp
      elif [ $1 == "help" ]; then
        require nmap
        nmap --help
      else
        require nmap
        if [ $# -eq 1 ]; then
          sudo nmap -sS -P0 -sV -O $1
        else
          nmap $*
        fi
      fi
  elif [ $1 == "ps" ] || [ $1 == "portstatus" ]; then
    shift
    if [ $# -eq 1 ]; then
      nhost="127.0.0.1"
      nport=$1
    elif [ $# -gt 1 ]; then
      nhost=$1
      nport=$2
    else
      echo "error: need arguments"
    fi
    if type nmap &>/dev/null; then
      nmap -p $nport $nhost
    elif type nc &>/dev/null; then
      nc $nhost $nport -zv
    elif type telnet &>/dev/null; then
      echo -e '\035\nquit' | telnet $nhost $nport
    elif type curl &>/dev/null; then
      curl -ksvIL http://${nhost}:${nport} > /dev/null
    else
      wget -qS -O- http://${nhost}:${nport} > /dev/null
    fi
  elif [ $1 == "it" ] || [ $1 == "iptable" ] || [ $1 == "iptables" ]; then
    shift
    if [ $1 == "h" ] || [ $1 == "hp" ]; then
      iptableshelp
    elif [ $1 == "help" ]; then
      require iptables
      iptables --help
    else
      require iptables
      iptables $*
    fi
  elif [ $1 == "n" ] || [ $1 == "net" ]; then
    shift
    subcmd=$1
    case "$subcmd" in
    "h" | "hp" | "help")
      nethelp
      ;;
    "arp")
      shift
      require arp
      if [ -z $1 ]; then
        arp -a
      else
        arp -a -i $1
      fi
      ;;
    "pi")
      shift
      if type nmap &>/dev/null; then
        sudo nmap -sP --disable-arp-ping $1
      elif type fping &>/dev/null; then
        fping -Ae $*
      else
        ping $*
      fi
      ;;
    "br")
      shift
      require brctl
      brctl $*
      ;;
    "brs")
      shift
      require brctl
      brctl show
      ;;
    "brl")
      shift
      require bridge
      bridge link show -d
      ;;
    "brv")
      shift
      require bridge
      bridge vlan show -d
      ;;
    "brf")
      shift
      require bridge
      bridge fdb show -d
      ;;
    "brm")
      shift
      require bridge
      bridge mdb show -d
      ;;
    "ip")
      shift
      require ip
      ip $*
      ;;
    "ipr")
      shift
      require ip
      ip r
      ;;
    "ipa")
      shift
      require ip jq
      getip "ipa" "$1"
      ;;
    "ipp")
      shift
      require ip jq
      getip "ipp" "$1"
      ;;
    "ips")
      shift
      require ip
      itfs=$(ip -j a|jq -r '.[].ifname' | grep "$1")
      itfs=($itfs)
      if [ ${#itfs[@]} -eq 1 ]; then
        titf="${itfs[0]}"
      else
        echo "====== More than one net interface ======"
        for ((i = 0; i < ${#itfs[@]}; i++)); do
          echo "$i: ${itfs[$i]}"
        done
        read -p "====== select one with number[0]: " iidx
        if [ -z $iidx ]; then
          iidx=0
        fi
        titf=${itfs[$iidx]}
      fi
      ip -s a show dev $titf
      ;;
    "tr")
      shift
      if ! type mtr &>/dev/null; then
        traceroute $*
      else
        if [ -z $1 ]; then
          mtr
        else
          mtr $*
        fi
      fi
      ;;
    "ss")
      shift
      if ! type ss &>/dev/null; then
        if [ -z $1 ]; then
          netstat -vatunlp
        else
          netstat $*
        fi
      else
        if [ -z $1 ]; then
          ss -asntup
        else
          ss $*
        fi
      fi
      ;;
    "nl")
      shift
      if type nslookup &>/dev/null; then
        nslookup $*
      else
        dig $*
      fi
      ;;
    "nm")
      shift
      if [ $1 == "h" ] || [ $1 == "hp" ]; then
        nmaphelp
      elif [ $1 == "help" ]; then
        require nmap
        nmap --help
      else
        require nmap
        if [ $# -eq 1 ]; then
          sudo nmap -sS -P0 -sV -O $1
        else
          nmap $*
        fi
      fi
      ;;
    "td")
      shift
      if [ $1 == "h" ] || [ $1 == "hp" ]; then
        tcpdumphelp
      elif [ $1 == "help" ]; then
        require tcpdump
        tcpdump --help
      else
        require tcpdump
        tcpdump $*
      fi
      ;;
    "ts")
      shift
      if [ $1 == "h" ] || [ $1 == "hp" ]; then
        tsharkhelp
      elif [ $1 == "help" ]; then
        require tshark
        tshark --help
      else
        require tshark
        tshark $*
      fi
      ;;
    "it")
      shift
      if [ $1 == "h" ] || [ $1 == "hp" ]; then
        iptableshelp
      elif [ $1 == "help" ]; then
        require iptables
        iptables --help
      else
        require iptables
        iptables $*
      fi
      ;;
    "ps")
      shift
      if [ $# -eq 1 ]; then
        nhost="127.0.0.1"
        nport=$1
      elif [ $# -gt 1 ]; then
        nhost=$1
        nport=$2
      else
        echo "error: need arguments"
      fi
      if type nmap &>/dev/null; then
        nmap -p $nport $nhost
      elif type nc &>/dev/null; then
        nc $nhost $nport -zv
      elif type telnet &>/dev/null; then
        echo -e '\035\nquit' | telnet $nhost $nport
      elif type curl &>/dev/null; then
        curl -ksvIL http://${nhost}:${nport} > /dev/null
      else
        wget -qS -O- http://${nhost}:${nport} > /dev/null
      fi
      ;;
    esac
  elif [ $1 == "ct" ] || [ $1 == "ssl" ] || [ $1 == "cred" ]; then
    require openssl
    shift
    if [ $# -ge 1 ]; then
      subcmd="$1"
      shift
      case "$subcmd" in
      "h" | "hp" | "help")
        sslhelp
        exit 0
        ;;
      "gen" | "generate")
        genssl "$*"
        ;;
      "out" | "show")
        if [ $# -eq 0 ]; then
          openssl x509 -noout -text -in *
        elif [ $# -eq 1 ]; then
          openssl x509 -noout -text -in $1
        elif [ $# -eq 2 ]; then
          openssl x509 -noout -$2 -in $1
        fi
        ;;
      "mat" | "match")
        if [ $# -eq 2 ]; then
          key=$(openssl rsa --noout --modulus --in $1 | openssl md5)
          cert=$(openssl x509 --noout --modulus --in $2 | openssl md5)
          if [ "$key" == "$cert" ]; then
            echo "true"
          else
            echo "false"
          fi
        else
          echo "error: need arguments"
        fi
        ;;
      "ver" | "verify")
        if [ $# -eq 2 ]; then
          openssl verify -verbose -CAfile $1 $2
        elif [ $# -eq 3 ]; then
          openssl verify -verbose -CAfile $1 -untrusted $2 $3
        else
          echo "error: need arguments"
        fi
        ;;
      "get" | "fetch")
        if [ $# -eq 1 ]; then
          openssl s_client -showcerts -verify 32 -connect $1 | openssl x509 -text
        else
          echo "error: need arguments"
        fi
        ;;
      "sver" | "sverify")
        if [ $# -eq 1 ]; then
          domain=${1##*/}
          domain=${domain%:*}
          openssl s_client -showcerts -verify 32 -servername $domain -connect $1
        elif [ $# -eq 2 ]; then
          openssl s_client -showcerts -verify 32 -servername $2 -connect $1
        else
          echo "error: need arguments"
        fi
        ;;
      esac
    fi
  elif [ $1 == "d" ] || [ $1 == "docker" ]; then
    require docker
    shift
    docker $*
  elif [ $1 == "dc" ] || [ $1 == "dkc" ] || [ $1 == "docker-compose" ]; then
    require docker-compose
    shift
    docker-compose $*
  elif [ $1 == "k" ] || [ $1 == "kube" ] || [ $1 == "kubectl" ]; then
    require kubectl
    shift
    kubectl $*
  elif [ $1 == "ghp" ] || [ $1 == "ghelp" ]; then
    require go
    shift
    go help $*
  elif [ $1 == "dhp" ] || [ $1 == "dhelp" ]; then
    require docker
    shift
    docker $* --help
  elif [ $1 == "khp" ] || [ $1 == "khelp" ]; then
    require kubectl
    shift
    kubectl $* --help
  elif [ $1 == "dq" ] || [ $1 == "dsearch" ]; then
    require docker
    shift
    docker search $*
  elif [ $1 == "dr" ] || [ $1 == "drun" ]; then
    require docker
    shift
    docker run $*
  elif [ $1 == "drt" ] || [ $1 == "dtmp" ]; then
    require docker
    shift
    docker run -it --rm $*
  elif [ $1 == "db" ] || [ $1 == "dbd" ]; then
    require docker
    shift
    docker build $*
  elif [ $1 == "sp" ] || [ $1 == "spl" ] || [ $1 == "sample" ]; then
    shift
    skind="pod"
    if [ $# -gt 0 ]; then
      skind=$1
    fi
    printSample "$skind"
  else
    while [ $# -gt 0 ] && [[ "$1" != "--" ]]; do
      while getopts "a:b:c:d:e:f:i:k:m:n:o:p:s:t:u:w:hjlrv" opt; do
        case $opt in
        a)
          since="--since $OPTARG"
          ;;
        b)
          amount="--tail $OPTARG"
          ;;
        c)
          context="--context $OPTARG"
          ;;
        d)
          savedir="$OPTARG"
          ;;
        e)
          selector="--selector=$OPTARG"
          ;;
        f)
          kc="--kubeconfig $OPTARG"
          ;;
        i)
          idx=$OPTARG
          ;;
        j)
          localrun=1
          ;;
        k)
          kind=$OPTARG
          ;;
        l)
          list=1
          ;;
        m)
          image=$OPTARG
          ;;
        n)
          namespace=$OPTARG
          ;;
        o)
          host="$OPTARG"
          ;;
        p)
          port=$OPTARG
          ;;
        r)
          chroot="-c 'chroot /proc/1/root/'"
          ;;
        s)
          passwd=$OPTARG
          ;;
        t)
          timeout=$OPTARG
          ;;
        u)
          user=$OPTARG
          ;;
        v)
          vol="-v /var/run/docker.sock:/var/run/docker.sock"
          ;;
        w)
          kwd=$OPTARG
          ;;
        h)
          usage
          exit 0
          ;;
        \?)
          echo "Invalid option: -$OPTARG" >&2
          exit 1
          ;;
        esac
      done

      shift $((OPTIND - 1))

      while [ $# -gt 0 ] && (! [[ "$1" =~ ^- ]] || [[ "$1" =~ ^-- ]]); do
        mandatory=("${mandatory[@]}" "$1")
        shift
        OPTIND=1 # reset OPTIND
      done
    done

    if [ "$1" == "--" ]; then
      shift
      mandatory=("${mandatory[@]}" "$@")
    fi

    if [ "$kind" == "dep" ]; then
      kind="deploy"
    fi

    if ! [[ "${mandatory[0]}" =~ ^- ]]; then
      subcmd=${mandatory[0]}
      mandatory=("${mandatory[@]:1}")
    fi

    if [ -z $subcmd ]; then
      echo "need sub command"
      usage simple
      exit 1
    fi

    if [ -z "$namespace" ]; then
      ns="--all-namespaces"
    else
      ns="-n $namespace"
    fi

    if [ "$subcmd" == "hp" ]; then
      usage simple
      exit 0
    elif [ "$subcmd" == "help" ]; then
      usage
      exit 0
    elif [ "$subcmd" == "c" ] || [ "$subcmd" == "cmd" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        cmd=${mandatory[0]}
        if [ ${#mandatory[@]} -eq 1 ]; then
          execmd "$cmd"
        else
          for ip in ${mandatory[@]:1}; do
            if [ $localrun -eq 0 ]; then
              execmd "$cmd" $ip
            else
              lexecmd "$cmd" $ip
            fi
          done
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "scp" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        cppaths=${mandatory[0]}
        if [ ${#mandatory[@]} -eq 1 ]; then
          remotecp "$cppaths"
        else
          for ip in ${mandatory[@]:1}; do
            remotecp "$cppaths" $ip
          done
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "gi" ]; then
      require git
      cmsg="update"
      if [ ${#mandatory[@]} -gt 0 ]; then
        cmsg=${mandatory[*]}
      fi
      git add -A .
      git commit -m "$cmsg"
      git push
    elif [ "$subcmd" == "pq" ] || [ "$subcmd" == "promq" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        sscmd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        echo "error: need arguments"
        exit 1
      fi
      if [ -n "$host" ]; then
        url=$host
      elif [ ${#mandatory[@]} -gt 0 ]; then
        if [[ "${mandatory[0]}" =~ "." ]] || [[ "${mandatory[0]}" = "localhost" ]]; then
          url="${mandatory[0]}"
          mandatory=("${mandatory[@]:1}")
        fi
      else
        url="127.0.0.1"
      fi
      if [ -n "$port" ]; then
        url=$url:$port
      fi
      require curl jq
      case "$sscmd" in
      "h" | "hp" | "help")
        promqhelp
        exit 0
        ;;
      "i" | "m" | "md" | "info" | "metadata")
        if [ ${#mandatory[@]} -eq 0 ]; then
          curl -Gks http://$url/api/v1/metadata
        fi
        if [ ${#mandatory[@]} -eq 1 ]; then
          metric="${mandatory[0]}"
          tgl="instance"
          insts=$(curl -Gks http://$url/api/v1/series --data-urlencode "match[]=$metric" |jq -r ".data[]|.instance")
#           SIFS=$IFS
#           IFS=$'\n'
#           insts=($insts)
#           IFS=$SIFS
          insts=($insts)
          if [ ${#insts[@]} -eq 0 ]; then
            exit 0
          elif [ ${#insts[@]} -eq 1 ]; then
            tgv="${insts[0]}"
          else
            echo "====== More than one instance ======"
            for ((i = 0; i < ${#insts[@]}; i++)); do
                echo "$i: ${insts[$i]}"
            done
            read -p "====== select one with number[0]: " iidx
            if [ -z $iidx ]; then
                iidx=0
            fi
            tgv=${insts[$iidx]}
          fi
        elif [ ${#mandatory[@]} -gt 1 ]; then
          metric="${mandatory[0]}"
          tgl=${mandatory[1]%=*}
          tgv=${mandatory[1]##*=}
          if [ "$tgl" == "$tgv" ]; then
            tgl="instance"
          fi
        fi
        curl -Gks http://$url/api/v1/targets/metadata --data-urlencode "match_target={$tgl=~\".*$tgv.*\"}" | jq -r ".data[] | select(.metric|contains(\"$metric\"))"
        ;;
      "s" | "inst" | "series" | "instance")
        if [ ${#mandatory[@]} -eq 0 ]; then
          echo "error: need arguments"
          exit 1
        fi
        metric="${mandatory[0]}"
        curl -Gks http://$url/api/v1/series --data-urlencode "match[]=$metric" | jq
        ;;
      "l" | "v" | "lv" | "label" | "value")
        if [ ${#mandatory[@]} -eq 0 ]; then
          curl -Gks http://$url/api/v1/labels | jq
        else
          curl -Gks http://$url/api/v1/label/${mandatory[0]}/values | jq
        fi
        ;;
      "t" | "tg" | "target")
        if [ ${#mandatory[@]} -eq 0 ]; then
          curl -Gks http://$url/api/v1/targets | jq
        else
          curl -Gks http://$url/api/v1/targets?state=${mandatory[0]} | jq
        fi
        ;;
      "r" | "rl" | "rule")
        if [ ${#mandatory[@]} -eq 0 ]; then
          curl -Gks http://$url/api/v1/rules | jq
        else
          curl -Gks http://$url/api/v1/rules?type=${mandatory[0]} | jq
        fi
        ;;
      "a" | "al" | "alert")
        curl -Gks http://$url/api/v1/alerts | jq
        ;;
      "am"  | "alertmanager")
        curl -Gks http://$url/api/v1/alertmanagers | jq
        ;;
      "v"  | "status")
        if [ ${#mandatory[@]} -eq 0 ]; then
          echo "========================== config =========================="
          curl -Gks http://$url/api/v1/status/config
          echo "========================== flags ==========================="
          curl -Gks http://$url/api/v1/status/flags
          echo "======================== runtimeinfo ======================="
          curl -Gks http://$url/api/v1/status/runtimeinfo
          echo "========================= buildinfo ========================"
          curl -Gks http://$url/api/v1/status/buildinfo
          echo "=========================== tsdb ==========================="
          curl -Gks http://$url/api/v1/status/tsdb
        else
          curl -Gks http://$url/api/v1/status/${mandatory[0]} | jq
        fi
        ;;
      "q" | "query")
        if [ ${#mandatory[@]} -eq 0 ]; then
          echo "error: need arguments"
          exit 1
        fi
        query="${mandatory[0]}"
        if [[ ! "$query" =~ ^query=.* ]]; then
          query="query=$query"
        fi
        if [ ${#mandatory[@]} -gt 1 ]; then
          ptime="--data-urlencode \"time=${mandatory[1]}\""
          if [ ${#mandatory[@]} -gt 2 ]; then
            ptimeout="--data-urlencode \"timeout=${mandatory[2]}\""
          fi
        fi
        curl -Gks http://$url/api/v1/query --data-urlencode "$query" $ptime $ptimeout | jq
        ;;
      "qr" | "rq" | "query_range")
        if [ ${#mandatory[@]} -eq 0 ]; then
          echo "error: need arguments"
          exit 1
        fi
        query="${mandatory[0]}"
        if [[ ! "$query" =~ ^query=.* ]]; then
          query="query=$query"
        fi
        if [ ${#mandatory[@]} -gt 1 ]; then
          stime="--data-urlencode \"start=${mandatory[1]}\""
          if [ ${#mandatory[@]} -gt 2 ]; then
            etime="--data-urlencode \"end=${mandatory[2]}\""
            if [ ${#mandatory[@]} -gt 3 ]; then
              step="--data-urlencode \"step=${mandatory[3]}\""
              if [ ${#mandatory[@]} -gt 4 ]; then
                ptimeout="--data-urlencode \"timeout=${mandatory[2]}\""
              fi
            fi
          fi
        fi
        curl -Gks http://$url/api/v1/query_range --data-urlencode "$query" $stime $etime $step $ptimeout | jq
        ;;
      default)
        curl -Gks ${mandatory[*]} | jq
        ;;
      esac
    elif [ "$subcmd" == "dps" ] || [ "$subcmd" == "dlist" ]; then
      if [ -n "$kwd" ]; then
        cmd="docker ps -a | grep $kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        cmd="docker ps -a | grep ${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        cmd="docker ps -a"
      fi
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dm" ] || [ "$subcmd" == "dim" ] || [ "$subcmd" == "dimg" ]; then
      if [ -n "$kwd" ]; then
        cmd="docker image ls | grep $kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        cmd="docker image ls | grep ${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        cmd="docker image ls"
      fi
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dn" ] || [ "$subcmd" == "dnet" ]; then
      if [ -n "$kwd" ]; then
        cmd="docker network ls | grep $kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        cmd="docker network ls | grep ${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        cmd="docker network ls"
      fi
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dv" ] || [ "$subcmd" == "dvol" ]; then
      if [ -n "$kwd" ]; then
        cmd="docker volume ls | grep $kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        cmd="docker volume ls | grep ${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        cmd="docker volume ls"
      fi
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dcc" ]; then
      cmd="docker rm $(docker ps -qaf 'status=exited')"
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dic" ]; then
      cmd="docker image prune -a"
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dvc" ]; then
      cmd="docker volume prune"
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dnc" ]; then
      cmd="docker network prune"
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "ds" ] || [ "$subcmd" == "dput" ] || [ "$subcmd" == "dpush" ]; then
      require docker
      if [ ${#mandatory[@]} -gt 0 ]; then
        imgname=${mandatory[0]%:*}
        imgtag=${mandatory[0]##*:}
        if [ $imgname == $imgtag ]; then
          imgtag=""
        fi
        #       if [ -z $imgtag ] || [ $imgtag == "" ]; then
        #         imgtag="latest"
        #       fi
        #     if [ $(docker images|grep $imgname|awk '{print $2}'|grep $imgtag|wc -l) -eq 0 ]; then
        if [ -z $imgtag ] && [ $(docker images | grep $imgname | wc -l) -gt 1 ]; then
          #         docker pull $imgname:$imgtag
          echo "====== More than one image ======"
          imgs=$(docker images | grep $imgname | awk '{print $1":"$2}')
          SIFS=$IFS
          IFS=$'\n'
          imgs=($imgs)
          IFS=$SIFS
          for ((i = 0; i < ${#imgs[@]}; i++)); do
            echo "$i: ${imgs[$i]}"
          done
          imgtag="latest"
          echo "-1: pull $imgname:$imgtag"
          read -p "====== select one with number[0]: " iidx
          if [ -z $iidx ]; then
            iidx=0
          fi
          if [ $iidx -eq -1 ]; then
            docker pull $imgname:$imgtag
            irs=$imgname:$imgtag
          else
            irs=${imgs[$iidx]}
          fi
          llib=${irs%/*}
          limg=${irs##*/}
        elif [ $(docker images | grep $imgname | wc -l) -eq 0 ]; then
          pimg=$imgname:latest
          docker pull $pimg
          llib=${pimg%/*}
          limg=${pimg##*/}
        else
          if [ -z $imgtag ]; then
            imgtag="latest"
          fi
          pimg=$imgname:$imgtag
          llib=${pimg%/*}
          limg=${pimg##*/}
        fi

        if [ $llib == $limg ]; then
          llib=""
        fi

        if [ ${#mandatory[@]} -gt 1 ]; then
          rrepo=${mandatory[1]%%/*}
          rlib=${mandatory[1]#*/}
        fi

        rimg=${rlib#*/}
        rlib=${rlib%%/*}

        if [ "$rimg" == "$rlib" ]; then
          rimg=""
        fi

        if [ "$rlib" == "" ] || [ "$rlib" == "$rrepo" ]; then
          if [[ "$rrepo" =~ "." ]]; then
            rlib="library"
          else
            rlib=$rrepo
            rrepo="docker.io"
          fi
        fi

        if [ -z "$rlib" ]; then
          if [ -n "$llib" ]; then
            rlib=$llib
          else
            rlib="library"
          fi
        fi
        if [ -z "$rrepo" ]; then
          rrepo="docker.io"
        fi

        if [ -z $llib ]; then
          simg=$limg
        else
          simg=$llib/$limg
        fi

        if [ "$rimg" != "$limg" ] && [ -n $rimg ] && [ "$rimg" != "" ]; then
          limg=$rimg
        fi

        docker tag $simg $rrepo/$rlib/$limg
        docker push $rrepo/$rlib/$limg
        if [ "$rrepo" != "docker.io" ]; then
          docker rmi -f $rrepo/$rlib/$limg
        fi
      else
        echo "error: need arguments"
      fi
    elif [ "$subcmd" == "dl" ] || [ "$subcmd" == "dget" ] || [ "$subcmd" == "dpull" ]; then
      cmd="docker pull ${mandatory[0]}"
      if [ ${#mandatory[@]} -eq 1 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]:1}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dd" ] || [ "$subcmd" == "drm" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker rm -f $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          conts=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          conts=($conts)
          IFS=$SIFS
          for ((i = 0; i < ${#conts[@]}; i++)); do
            echo "$i: ${conts[$i]}"
          done
          echo "-1: ALL"
          read -p "====== select one with number[0]: " dcidx
          if [ -z $dcidx ]; then
            dcidx=0
          fi
          if [ $dcidx -eq -1 ]; then
            docker rm -f $(docker ps -a | grep "$fkwd" | awk '{print $1}')
          else
            docker rm -f $(echo ${conts[$dcidx]} | awk '{print $1}')
          fi
        fi
      else
        cmd="docker rm -f $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dcp" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
        if [ -z "$args" ] && [ ${#mandatory[@]} -gt 0 ]; then
          args="${mandatory[*]}"
        else
          echo "error: need arguments"
          exit 1
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
      if [ -n "$fkwd" ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          tcid=$(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          conts=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          conts=($conts)
          IFS=$SIFS
          for ((i = 0; i < ${#conts[@]}; i++)); do
            echo "$i: ${conts[$i]}"
          done
          read -p "====== select one with number[0]: " dcidx
          if [ -z $dcidx ]; then
            dcidx=0
          fi
          tcid=$(echo ${conts[$dcidx]} | awk '{print $1}')
        fi
        prearg=$(echo "$args" | awk -F ':' '{print $1}')
        sufarg=$(echo "$args" | awk -F ':' '{print $2}')
        if [ "$prearg" == "" ]; then
          prearg="$tcid:"$prearg
        else
          sufarg="$tcid:"$sufarg
        fi
        docker cp $prearg$sufarg
      fi
    elif [ "$subcmd" == "dx" ] || [ "$subcmd" == "dbg" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
        if ([ -z "$image" ] || [ "$image" == "xo" ]) && [ ${#mandatory[@]} -gt 0 ]; then
          image="${mandatory[0]}"
        elif [ -z "$image" ]; then
          image="busybox"
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
      if [ -n "$fkwd" ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          tcid=$(docker ps -a | grep "$fkwd" | awk '{print $1}')
          docker run -it --network=container:$tcid --pid=container:$tcid --ipc=container:$tcid $image
        else
          echo "====== More than one container ======"
          conts=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          conts=($conts)
          IFS=$SIFS
          for ((i = 0; i < ${#conts[@]}; i++)); do
            echo "$i: ${conts[$i]}"
          done
          read -p "====== select one with number[0]: " dcidx
          if [ -z $dcidx ]; then
            dcidx=0
          fi
          tcid=$(echo ${conts[$dcidx]} | awk '{print $1}')
          docker run -it --network=container:$tcid --pid=container:$tcid --ipc=container:$tcid $image
        fi
      fi
    elif [ "$subcmd" == "de" ] || [ "$subcmd" == "dexe" ] || [ "$subcmd" == "dexec" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
        if [ ${#mandatory[@]} -gt 0 ]; then
          dcmd="${mandatory[*]}"
        else
          dcmd="sh"
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
      if [ -n "$fkwd" ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker exec $(docker ps -a | grep "$fkwd" | awk '{print $1}') $dcmd
        else
          echo "====== More than one container ======"
          conts=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          conts=($conts)
          IFS=$SIFS
          for ((i = 0; i < ${#conts[@]}; i++)); do
            echo "$i: ${conts[$i]}"
          done
          read -p "====== select one with number[0]: " dcidx
          if [ -z $dcidx ]; then
            dcidx=0
          fi
          docker exec $(echo ${conts[$dcidx]} | awk '{print $1}') $dcmd
        fi
      fi
    elif [ "$subcmd" == "die" ] || [ "$subcmd" == "diexe" ] || [ "$subcmd" == "diexec" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker exec -it $(docker ps -a | grep "$fkwd" | awk '{print $1}') sh
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker exec -it $(echo ${cimgs[$dcidx]} | awk '{print $1}') sh
        fi
      else
        cmd="docker exec -it $fkwd sh"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dat" ] || [ "$subcmd" == "dattach" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker attach $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker attach $(echo ${cimgs[$dcidx]} | awk '{print $1}')
        fi
      else
        cmd="docker attach $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dlg" ] || [ "$subcmd" == "dlog" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker logs $(docker ps -a | grep "$fkwd" | awk '{print $1}') $since $amount
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker logs $(echo ${cimgs[$dcidx]} | awk '{print $1}') $since $amount
        fi
      else
        cmd="docker logs $fkwd $since $amount"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dlf" ] || [ "$subcmd" == "dlogf" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ -n "$fkwd" ] && [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker logs -f $(docker ps -a | grep "$fkwd" | awk '{print $1}') $since $amount
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker logs -f $(echo ${cimgs[$dcidx]} | awk '{print $1}') $since $amount
        fi
      else
        cmd="docker logs -f $fkwd $since $amount"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dmi" ] || [ "$subcmd" == "dmin" ] || [ "$subcmd" == "dminsp" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker images | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect $(docker images | grep "$fkwd" | awk '{print $3}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker image list --format '{{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker inspect $(echo ${cimgs[$diidx]} | awk '{print $3}')
        fi
      else
        cmd="docker inspect $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "di" ] || [ "$subcmd" == "din" ] || [ "$subcmd" == "dinsp" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker inspect $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dsa" ] || [ "$subcmd" == "dstart" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker start $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker start $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker start $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dsp" ] || [ "$subcmd" == "dstop" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker stop $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker stop $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker stop $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dtp" ] || [ "$subcmd" == "dtop" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker top $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker top $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker top $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dst" ] || [ "$subcmd" == "dstat" ] || [ "$subcmd" == "dstat" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ -z "$fkwd" ]; then
          docker stats
        elif [ $(docker ps | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker stats $(docker ps | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker stats $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker stats $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dt" ] || [ "$subcmd" == "dtg" ] || [ "$subcmd" == "dtag" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        echo "error: need arguments"
        exit 1
      else
        ttag="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker images | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker tag $(docker images | grep "$fkwd" | awk '{print $3}') $ttag
        else
          echo "====== More than one container ======"
          cimgs=$(docker image list --format '{{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker tag $(echo ${cimgs[$diidx]} | awk '{print $3}') $ttag
        fi
      else
        cmd="docker tag $fkwd $ttag"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "do" ] || [ "$subcmd" == "drmi" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker images | grep "$fkwd" | wc -l) -lt 2 ]; then
          if [ $(docker images | grep "$fkwd" | awk '{print $1}') == "<none>" ]; then
            docker rmi -f $(docker images | grep "$fkwd" | awk '{print $3}')
          else
            docker rmi -f $(docker images | grep "$fkwd" | awk '{print $1":"$2}')
          fi
        else
          echo "====== More than one container ======"
          cimgs=$(docker image list --format '{{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          echo "-1: ALL"
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          if [ $diidx -eq -1 ]; then
            docker rmi -f $(docker images | grep "$fkwd" | awk '{print $1":"$2}')
          else
            if [ $(echo ${cimgs[$diidx]} | awk '{print $1}') == "<none>" ]; then
              docker rmi -f $(echo ${cimgs[$diidx]} | awk '{print $3}')
            else
              docker rmi -f $(echo ${cimgs[$diidx]} | awk '{print $1":"$2}')
            fi
          fi
        fi
      else
        cmd="docker rmi -f $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dh" ] || [ "$subcmd" == "dhi" ] || [ "$subcmd" == "dhist" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker images | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker history $(docker images | grep "$fkwd" | awk '{print $3}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker image list --format '{{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker history $(echo ${cimgs[$diidx]} | awk '{print $3}')
        fi
      else
        cmd="docker history $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpa" ] || [ "$subcmd" == "daddr" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .NetworkSettings.Networks}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker inspect --format='{{json .NetworkSettings.Networks}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .NetworkSettings.Networks}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpe" ] || [ "$subcmd" == "denv" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .Config.Env}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker inspect --format='{{json .Config.Env}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .Config.Env}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpc" ] || [ "$subcmd" == "dcmd" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .Config.Cmd}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker inspect --format='{{json .Config.Cmd}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .Config.Cmd}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpp" ] || [ "$subcmd" == "dport" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .NetworkSettings.Ports}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker inspect --format='{{json .NetworkSettings.Ports}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .NetworkSettings.Ports}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpm" ] || [ "$subcmd" == "dmnt" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .Mounts}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z $diidx ]; then
            diidx=0
          fi
          docker inspect --format='{{json .Mounts}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .Mounts}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "cf" ] || [ "$subcmd" == "cfind" ]; then
      grep -nr "${mandatory[*]}"
    elif [ "$subcmd" == "df" ] || [ "$subcmd" == "dfind" ]; then
      require docker
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi

      items=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' 2>/dev/null)
      SIFS=$IFS
      IFS=$'\n'
      items=($items)
      IFS=$SIFS

      for ((i = 0; i < ${#items[@]}; i++)); do
        lid=$(echo ${items[$i]} | awk '{print $1}')
        if [ $(docker inspect $lid | grep "$kwd" | wc -l) -gt 0 ]; then
          echo ${items[$i]}
        fi
      done
    elif [ "$subcmd" == "cfg" ] || [ "$subcmd" == "config" ]; then
      require kubectl
      kubectl $kc $context config view
    elif [ "$subcmd" == "dump" ]; then
      require kubectl
      kubectl $kc $context cluster-info dump
    elif [ "$subcmd" == "exp" ] || [ "$subcmd" == "explain" ]; then
      require kubectl
      if [ ${#mandatory[@]} -gt 0 ]; then
        kubectl $kc $context explain ${mandatory[@]}
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "expr" ] || [ "$subcmd" == "explainr" ]; then
      require kubectl
      if [ ${#mandatory[@]} -gt 0 ]; then
        kubectl $kc $context explain ${mandatory[@]} --recursive
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "dry" ] || [ "$subcmd" == "dryrun" ]; then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 0 ]; then
        kubectl $kc $context ${mandatory[@]} --dry-run
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "ap" ] || [ "$subcmd" == "apl" ] || [ "$subcmd" == "apply" ]; then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 0 ]; then
        for fname in ${mandatory[@]}; do
          kubectl $kc $context apply -f $fname $selector $ns
        done
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "cr" ] || [ "$subcmd" == "crt" ] || [ "$subcmd" == "create" ]; then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 0 ]; then
        isfile="true"
        for fname in ${mandatory[@]}; do
          if ! [[ $fname =~ .yaml$ ]] && ! [[ $fname =~ .yml$ ]] && ! [[ $fname =~ .json$ ]]; then
            isfile="false"
            break
          fi
        done
        if [ "$isfile" == "true" ]; then
          for fname in ${mandatory[@]}; do
            kubectl $kc $context create -f $fname $selector $ns
          done
        else
          kubectl $kc $context create $kind ${mandatory[@]} $selector $ns
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "r" ] || [ "$subcmd" == "run" ]; then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 1 ]; then
        kubectl $kc $context run ${mandatory[@]} $ns
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "b" ] || [ "$subcmd" == "rbac" ]; then
      require kubectl rback dot
      if [ -n "$savedir" ]; then
        kubectl $kc $context get sa,roles,rolebindings,clusterroles,clusterrolebindings $ns -o json | rback -show-legend=false ${mandatory[*]} | dot -Tsvg >$savedir/rbac.svg
      else
        dispapp="xdg-open"
        if type display &>/dev/null; then
          dispapp="display"
        elif type inkview &>/dev/null; then
          dispapp="inkview"
        elif type feh &>/dev/null; then
          dispapp="feh --conversion-timeout 1"
        fi
        kubectl $kc $context get sa,roles,rolebindings,clusterroles,clusterrolebindings $ns -o json | rback -show-legend=false ${mandatory[*]} | dot -Tsvg | $dispapp
      fi
    elif [ "$subcmd" == "a" ] || [ "$subcmd" == "all" ]; then
      require kubectl
      kubectl $kc $context get all $selector $ns
    elif [ "$subcmd" == "eg" ] || [ "$subcmd" == "etcdget" ]; then
      require etcdctl
      if [ -d /etc/kubernetes/pki ]; then
        rpath="/etc/kubernetes/pki"
      else
        rpath="/etc/kubernetes/ssl"
      fi
      if [ -z "$host" ]; then
        host="127.0.0.1"
      fi
      if [ -z "$port" ]; then
        port="2379"
      fi
      ep="$host:$port"
      if [ ${#mandatory[@]} -eq 1 ]; then
        if [ -f $rpath/ca.crt ]; then
          ca=$rpath/ca.crt
        else
          ca=$rpath/kube-ca.pem
        fi
        if [ -f $rpath/etcd/peer.crt ]; then
          cert=$rpath/etcd/peer.crt
        else
          cert=$rpath/$(ls $rpath | grep etcd | grep -v key.pem | sed -n '1p')
        fi
        if [ -f $rpath/etcd/peer.key ]; then
          key=$rpath/etcd/peer.key
        else
          key=$rpath/$(ls $rpath | grep etcd | grep key.pem | sed -n '1p')
        fi
        etcdkey=${mandatory[0]}
      elif [ ${#mandatory[@]} -eq 4 ]; then
        ca=${mandatory[0]}
        cert=${mandatory[1]}
        key=${mandatory[2]}
        etcdkey=${mandatory[3]}
        if [ "${ca:0:1}" != "/" ]; then
          ca=$rpath/$ca
        fi
        if [ "${cert:0:1}" != "/" ]; then
          cert=$rpath/$cert
        fi
        if [ "${key:0:1}" != "/" ]; then
          key=$rpath/$key
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
      echo "=== endpoint: $ep | cacert: $ca | cert: $cert | key: $key ==="
      ETCDCTL_API=3 etcdctl --endpoints=$ep --cacert=$ca --cert=$cert --key=$key get "$etcdkey" -w=json
    elif [ "$subcmd" == "egp" ] || [ "$subcmd" == "etcdgetp" ]; then
      require etcdctl
      if [ -d /etc/kubernetes/pki ]; then
        rpath="/etc/kubernetes/pki"
      else
        rpath="/etc/kubernetes/ssl"
      fi
      if [ -z "$host" ]; then
        host="127.0.0.1"
      fi
      if [ -z "$port" ]; then
        port="2379"
      fi
      ep="$host:$port"
      if [ ${#mandatory[@]} -eq 1 ]; then
        if [ -f $rpath/ca.crt ]; then
          ca=$rpath/ca.crt
        else
          ca=$rpath/kube-ca.pem
        fi
        if [ -f $rpath/etcd/peer.crt ]; then
          cert=$rpath/etcd/peer.crt
        else
          cert=$rpath/$(ls $rpath | grep etcd | grep -v key.pem | sed -n '1p')
        fi
        if [ -f $rpath/etcd/peer.key ]; then
          key=$rpath/etcd/peer.key
        else
          key=$rpath/$(ls $rpath | grep etcd | grep key.pem | sed -n '1p')
        fi
        etcdkey=${mandatory[0]}
      elif [ ${#mandatory[@]} -eq 4 ]; then
        ca=${mandatory[0]}
        cert=${mandatory[1]}
        key=${mandatory[2]}
        etcdkey=${mandatory[3]}
        if [ "${ca:0:1}" != "/" ]; then
          ca=$rpath/$ca
        fi
        if [ "${cert:0:1}" != "/" ]; then
          cert=$rpath/$cert
        fi
        if [ "${key:0:1}" != "/" ]; then
          key=$rpath/$key
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
      echo "=== endpoint: $ep | cacert: $ca | cert: $cert | key: $key ==="
      ETCDCTL_API=3 etcdctl --endpoints=$ep --cacert=$ca --cert=$cert --key=$key get "$etcdkey" --prefix -w=json
    elif [ "$subcmd" == "np" ] || [ "$subcmd" == "nodepod" ]; then
      require kubectl
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi
      nodes=$(kubectl $kc $context get node $selector -o wide --no-headers | grep "$kwd")
      SIFS=$IFS
      IFS=$'\n'
      nodes=($nodes)
      IFS=$SIFS
      if [ ${#nodes[@]} -eq 0 ]; then
        exit 0
      elif [ ${#nodes[@]} -eq 1 ]; then
        node=${nodes[0]}
      else
        echo "====== More than one node ======"
        for ((i = 0; i < ${#nodes[@]}; i++)); do
          echo "$i: ${nodes[$i]}"
        done
        read -p "====== select one with number[0]: " niidx
        if [ -z $niidx ]; then
          niidx=0
        fi
        node=${nodes[$niidx]}
      fi
      nodeip=$(echo "$node" | awk '{print $6}')
      kubectl $kc $context get pod -o wide $selector $ns | grep -E "NAME|$nodeip"
    elif [ "$subcmd" == "ni" ] || [ "$subcmd" == "nodeimg" ]; then
      require kubectl
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi
      nodes=$(kubectl $kc $context get node $selector -o wide --no-headers | grep "$kwd")
      SIFS=$IFS
      IFS=$'\n'
      nodes=($nodes)
      IFS=$SIFS
      if [ ${#nodes[@]} -eq 0 ]; then
        exit 0
      elif [ ${#nodes[@]} -eq 1 ]; then
        node=${nodes[0]}
      else
        echo "====== More than one node ======"
        for ((i = 0; i < ${#nodes[@]}; i++)); do
          echo "$i: ${nodes[$i]}"
        done
        read -p "====== select one with number[0]: " niidx
        if [ -z $niidx ]; then
          niidx=0
        fi
        node=${nodes[$niidx]}
      fi
      nodename=$(echo "$node" | awk '{print $1}')
      kubectl get node $nodename -o jsonpath='{.status.images[*].names[*]}' | sed 's/ /\n/g' | grep -v "@sha256"
    elif [ "$subcmd" == "tk" ] || [ "$subcmd" == "token" ]; then
      require kubectl base64
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi
      sas=$(kubectl $kc $context get serviceaccount --no-headers $selector $ns | grep "$kwd")
      SIFS=$IFS
      IFS=$'\n'
      sas=($sas)
      IFS=$SIFS
      if [ ${#sas[@]} -eq 0 ]; then
        exit 0
      elif [ ${#sas[@]} -eq 1 ]; then
        sa=${sas[0]}
      else
        echo "====== More than one serviceaccount ======"
        for ((i = 0; i < ${#sas[@]}; i++)); do
          echo "$i: ${sas[$i]}"
        done
        read -p "====== select one with number[0]: " siidx
        if [ -z $siidx ]; then
          siidx=0
        fi
        sa=${sas[$siidx]}
      fi
      if [ "$ns" == "--all-namespaces" ]; then
        lns=$(echo "$sa" | awk '{print $1}')
        lrs=$(echo "$sa" | awk '{print $2}')
      else
        lns=$(echo "$ns" | awk '{print $2}')
        lrs=$(echo "$sa" | awk '{print $1}')
      fi
      kubectl $kc $context -n $lns get secret $(kubectl $kc $context get serviceaccount $lrs -n $lns -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 --decode
    elif [ "$subcmd" == "re" ] || [ "$subcmd" == "res" ]; then
      require kubectl
      kubectl $kc $context api-resources
    elif [ "$subcmd" == "ver" ] || [ "$subcmd" == "version" ]; then
      require kubectl
      kubectl $kc $context api-versions
    elif [ "$subcmd" == "ro" ] || [ "$subcmd" == "rollout" ]; then
      require kubectl
      kubectl $kc $context rollout ${mandatory[@]} $selector $ns
    elif [ "$subcmd" == "au" ] || [ "$subcmd" == "auth" ]; then
      require kubectl
      kubectl $kc $context auth "${mandatory[@]}" $ns
    elif [ "$subcmd" == "pr" ] || [ "$subcmd" == "proxy" ]; then
      require kubectl
      if [[ "${mandatory[*]}" =~ ":" ]]; then
        ip=$(echo "${mandatory[*]}" | awk -F ':' '{print $1}')
        pt=$(echo "${mandatory[*]}" | awk -F ':' '{print $2}')
      else
        pt=${mandatory[*]}
      fi
      if [ -z "$ip" ]; then
        ip="127.0.0.1"
      fi
      if [ -z "$pt" ]; then
        if [ -n "$port" ]; then
          pt=$port
        else
          pt="8001"
        fi
      fi
      kubectl $kc $context proxy --address $ip --port $pt
    elif [ "$subcmd" == "li" ] || [ "$subcmd" == "lsimg" ]; then
      require kubectl
      # kubectl get pods --all-namespaces -o jsonpath="{.items[*].spec.containers[*].image}"
      echo $(kubectl $kc $context get pod -o go-template --template="{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}" $selector $ns) | sed 's/ /\n/g' | sort | uniq | tr '\n' ' '
    elif [ "$subcmd" == "lli" ] || [ "$subcmd" == "llimg" ]; then
      kubectl $kc $context get pod -o=jsonpath='{range .items[*]}{"\n"}{.metadata.name}{":\t"}{range .spec.containers[*]}{.image}{", "}{end}{end}' $selector $ns | sort
    elif [ "$subcmd" == "kf" ] || [ "$subcmd" == "kfind" ]; then
      require kubectl
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi

      items=$(kubectl $kc $context get $kind --no-headers $selector $ns 2>/dev/null)
      SIFS=$IFS
      IFS=$'\n'
      items=($items)
      IFS=$SIFS

      for ((i = 0; i < ${#items[@]}; i++)); do
        if [ "$ns" == "--all-namespaces" ]; then
          lns=$(echo ${items[$i]} | awk '{print $1}')
          lrs=$(echo ${items[$i]} | awk '{print $2}')
        else
          lns=$(echo "$ns" | awk '{print $2}')
          lrs=$(echo ${items[$i]} | awk '{print $1}')
        fi

        if [ $(kubectl $kc $context -n $lns $selector get $kind $lrs -o yaml | grep "$kwd" | wc -l) -gt 0 ]; then
          echo -e "$lns\t$lrs"
        fi
      done
    else
      require kubectl
      if [ -z "$kwd" ]; then
        # kwd=${mandatory[${#mandatory[@]} - 1]}
        # if [ ${#mandatory[@]} -gt 1 ]; then
        #   args=${mandatory[@]::${#mandatory[@]}-1}
        # fi
        if [ ${#mandatory[@]} -gt 0 ]; then
          kwd=${mandatory[0]}
        fi
        if [ ${#mandatory[@]} -gt 1 ]; then
          args=${mandatory[@]:1}
        fi
      else
        args=${mandatory[@]}
      fi
      if [ -z "$kwd" ] || [ $list -eq 1 ]; then
        case $subcmd in
        "gt" | "get")
          if [ -n "$kwd" ]; then
            kubectl $kc $context get $kind $selector $ns | grep "$kwd"
          else
            kubectl $kc $context get $kind $selector $ns
          fi
          ;;
        "wt" | "watch")
          if [ -n "$kwd" ]; then
            kubectl $kc $context get $kind $selector $ns --watch | grep "$kwd"
          else
            kubectl $kc $context get $kind $selector $ns --watch
          fi
          ;;
        "w" | "wide")
          if [ -n "$kwd" ]; then
            kubectl $kc $context get $kind $selector $ns -o wide | grep "$kwd"
          else
            kubectl $kc $context get $kind $selector $ns -o wide
          fi
          ;;
        "wl" | "wlabel")
          if [ -n "$kwd" ]; then
            kubectl $kc $context get $kind $selector $ns -o wide --show-labels | grep "$kwd"
          else
            kubectl $kc $context get $kind $selector $ns -o wide --show-labels
          fi
          ;;
        "s" | "desc" | "describe")
          if [ -n "$kwd" ]; then
            items=$(kubectl $kc $context get $kind --no-headers $selector $ns | grep "$kwd" 2>/dev/null)
            SIFS=$IFS
            IFS=$'\n'
            items=($items)
            IFS=$SIFS
            for ((i = 0; i < ${#items[@]}; i++)); do
              if [ "$ns" == "--all-namespaces" ]; then
                lns=$(echo ${items[$i]} | awk '{print $1}')
                lrs=$(echo ${items[$i]} | awk '{print $2}')
              else
                lns=$(echo "$ns" | awk '{print $2}')
                lrs=$(echo ${items[$i]} | awk '{print $1}')
              fi
              kubectl $kc $context -n $lns $selector describe $kind $lrs
            done
          else
            kubectl $kc $context describe $kind $selector $ns
          fi
          ;;
        "y" | "yaml")
          if [ -n "$kwd" ]; then
            items=$(kubectl $kc $context get $kind --no-headers $selector $ns | grep "$kwd" 2>/dev/null)
            SIFS=$IFS
            IFS=$'\n'
            items=($items)
            IFS=$SIFS
            for ((i = 0; i < ${#items[@]}; i++)); do
              if [ "$ns" == "--all-namespaces" ]; then
                lns=$(echo ${items[$i]} | awk '{print $1}')
                lrs=$(echo ${items[$i]} | awk '{print $2}')
              else
                lns=$(echo "$ns" | awk '{print $2}')
                lrs=$(echo ${items[$i]} | awk '{print $1}')
              fi
              kubectl $kc $context -n $lns $selector get $kind $lrs -o yaml
            done
          else
            kubectl $kc $context get $kind $selector $ns -o yaml
          fi
          ;;
        "j" | "json")
          if [ -n "$kwd" ]; then
            items=$(kubectl $kc $context get $kind --no-headers $selector $ns | grep "$kwd" 2>/dev/null)
            SIFS=$IFS
            IFS=$'\n'
            items=($items)
            IFS=$SIFS
            for ((i = 0; i < ${#items[@]}; i++)); do
              if [ "$ns" == "--all-namespaces" ]; then
                lns=$(echo ${items[$i]} | awk '{print $1}')
                lrs=$(echo ${items[$i]} | awk '{print $2}')
              else
                lns=$(echo "$ns" | awk '{print $2}')
                lrs=$(echo ${items[$i]} | awk '{print $1}')
              fi
              kubectl $kc $context -n $lns $selector get $kind $lrs -o json
            done
          else
            kubectl $kc $context get $kind $selector $ns -o json
          fi
          ;;
        "tp" | "top")
          if [ "$ns" == "--all-namespaces" ]; then
            ns="-n default"
          fi
          if [ "$kind" == "pod" ] || [ "$kind" == "node" ]; then
            if [ -n "$kwd" ]; then
              if [ "$kind" == "node" ]; then
                kubectl $kc $context top $kind $selector $ns | grep "$kwd"
              else
                items=$(kubectl $kc $context get $kind --no-headers $selector $ns | grep "$kwd" 2>/dev/null)
                SIFS=$IFS
                IFS=$'\n'
                items=($items)
                IFS=$SIFS
                for ((i = 0; i < ${#items[@]}; i++)); do
                  if [ "$ns" == "--all-namespaces" ]; then
                    lns=$(echo ${items[$i]} | awk '{print $1}')
                    lrs=$(echo ${items[$i]} | awk '{print $2}')
                  else
                    lns=$(echo "$ns" | awk '{print $2}')
                    lrs=$(echo ${items[$i]} | awk '{print $1}')
                  fi
                  kubectl $kc $context -n $lns $selector top $kind $lrs
                done
              fi
            else
              kubectl $kc $context top $kind $selector $ns
            fi
          fi
          ;;
        esac
        exit 0
      fi

      hasnsfield="false"
      ress=()
      result=$(kubectl $kc $context get $kind $selector $ns 2>/dev/null)
      SIFS=$IFS
      IFS=$'\n'
      result=($result)
      IFS=$SIFS
      if [[ $(echo "${result[0]}" | awk '{print $1}') == "NAMESPACE" ]]; then
        hasnsfield="true"
      fi
      for ((i = 1; i < ${#result[@]}; i++)); do
        if [[ "${result[$i]}" =~ "$kwd" ]]; then
          ress+=("${result[$i]}")
        fi
      done
      #ress=($(echo ${result[@]:1} | grep "$kwd"))

      if [ $? -ne 0 ] || [ ${#ress[@]} -eq 0 ]; then
        echo "No $kind resources found with keyword $kwd"
        exit 1
      fi

      if [ ${#ress[@]} -eq 1 ]; then
        rs=$ress
      else
        echo "====== More than one $kind ======"
        for ((i = 0; i < ${#ress[@]}; i++)); do
          echo "$i: ${ress[$i]}"
        done
        # echo "====== Selected the first ======"
        read -p "====== select one with number[0]: " ridx
        if [ -z $ridx ]; then
          ridx=0
        fi
        rs=${ress[$ridx]}
      fi
      if [ "$ns" == "--all-namespaces" ]; then
        if [ "$hasnsfield" == "false" ]; then
          resname=$(echo $rs | awk '{print $1}')
        else
          resname=$(echo $rs | awk '{print $2}')
          namespace=$(echo $rs | awk '{print $1}')
          ns="-n $namespace"
        fi
      else
        resname=$(echo $rs | awk '{print $1}')
      fi

      if [ "$kind" == "pod" ]; then
        podinfo=$(kubectl $kc $context get pod $resname $ns -o=custom-columns=NODE:.spec.nodeName,HOST:.status.hostIP,NAME:.metadata.name,ADDR:.status.podIP,CNAME:.status.containerStatuses[$idx].name,CID:.status.containerStatuses[$idx].containerID 2>/dev/null | grep $resname)

        if [ $? -ne 0 ]; then
          echo "$resname[$idx] container not found"
          exit 1
        fi

        hname=$(echo $podinfo | awk '{print $1}')
        haddr=$(echo $podinfo | awk '{print $2}')
        pname=$(echo $podinfo | awk '{print $3}')
        caddr=$(echo $podinfo | awk '{print $4}')
        cname=$(echo $podinfo | awk '{print $5}')
        cid=$(echo $podinfo | awk '{print $6}')
        cid=${cid#*docker://}
        cid=${cid:0:12}

        echo "=================================================================================================================================================="
        echo "Namespace: "${ns#-n } "HostName: "$hname "HostIP:"$haddr "PodName:"$pname "PodIP:"$caddr "CName:"$cname "CID:"$cid
        echo "=================================================================================================================================================="

        if [ -n "$host" ]; then
          haddr=$host
        fi
      fi

      case $subcmd in
      "l" | "log")
        if [ "$kind" == "pod" ]; then
          if [ "$(hostname)" == "$hname" ] && type docker &>/dev/null; then
            docker logs $cid $since $amount
          else
            kubectl $kc $context logs $resname $cname $since $amount $ns
          fi
        else
          echo "subcmd log not fit for $kind"
        fi
        ;;
      "lf" | "logf")
        if [ "$kind" == "pod" ]; then
          if [ $(hostname) == "$hname" ] && type docker &>/dev/null; then
            docker logs -f $cid $since $amount
          else
            kubectl $kc $context logs -f $resname $cname $since $amount $ns
          fi
        else
          echo "subcmd logf not fit for $kind"
        fi
        ;;
      "i" | "insp" | "inspect")
        if [ "$kind" == "pod" ]; then
          if [ "$(hostname)" == "$hname" ] && type docker &>/dev/null; then
            docker inspect $cid
          else
            execmd "docker inspect $cid" $haddr
          fi
        else
          echo "subcmd inspect not fit for $kind"
        fi
        ;;
      "gt" | "get")
        kubectl $kc $context get $kind $resname $ns
        ;;
      "s" | "desc" | "describe")
        kubectl $kc $context describe $kind $resname $ns
        ;;
      "wt" | "watch")
        kubectl $kc $context get $kind $resname $ns --watch
        ;;
      "w" | "wide")
        kubectl $kc $context get $kind $resname $ns -o wide
        ;;
      "wl" | "wlabel")
        kubectl $kc $context get $kind $resname $ns -o wide --show-labels
        ;;
      "y" | "yaml")
        kubectl $kc $context get $kind $resname $ns -o yaml
        ;;
      "j" | "json")
        kubectl $kc $context get $kind $resname $ns -o json
        ;;
      "tp" | "top")
        if [ "$ns" == "--all-namespaces" ]; then
          ns="-n default"
        fi
        if [ "$kind" == "pod" ] || [ "$kind" == "node" ]; then
          kubectl $kc $context top $kind $resname $ns
        fi
        ;;
      "ed" | "edit")
        kubectl $kc $context edit $kind $resname $ns
        ;;
      "p" | "patch")
        kubectl $kc $context patch $kind $resname $ns --patch $args
        ;;
      "rm" | "del" | "delete")
        isfile="true"
        for fname in ${mandatory[@]}; do
          if ! [[ $fname =~ .yaml$ ]] && ! [[ $fname =~ .yml$ ]] && ! [[ $fname =~ .json$ ]]; then
            isfile="false"
            break
          fi
        done
        if [ "$isfile" == "true" ]; then
          for fname in ${mandatory[@]}; do
            kubectl $kc $context delete -f $fname
          done
        else
          kubectl $kc $context delete $kind $resname $ns
        fi
        ;;
      "e" | "exe" | "exec")
        if [ "$kind" == "pod" ]; then
          kubectl $kc $context exec $resname -c $cname $args $ns
        else
          echo "subcmd exec not fit for $kind"
        fi
        ;;
      "ie" | "iexe" | "iexec")
        if [ $kind == "pod" ]; then
          kubectl $kc $context exec -it $resname -c $cname sh $ns
        else
          echo "subcmd iexec not fit for $kind"
        fi
        ;;
      "at" | "attach")
        if [ "$kind" == "pod" ]; then
          kubectl $kc $context attach $resname -c $cname $ns
        else
          echo "subcmd attach not fit for $kind"
        fi
        ;;
      "cp" | "copy")
        if [ "$kind" == "pod" ]; then
          prearg=$(echo "$args" | awk -F ':' '{print $1}')
          sufarg=$(echo "$args" | awk -F ':' '{print $2}')
          if [ "$prearg" == "" ]; then
            prearg="$resname:"$prearg
          else
            sufarg="$resname:"$sufarg
          fi
          kubectl $kc $context cp $prearg$sufarg $ns
        else
          echo "subcmd copy not fit for $kind"
        fi
        ;;
      "pf" | "forward" | "port-forward")
        if [ "$kind" == "pod" ]; then
          kubectl $kc $context port-forward $resname $args $ns
        else
          echo "subcmd port-forward not fit for $kind"
        fi
        ;;
      "x" | "deb" | "debug")
        if [ "$kind" == "pod" ]; then
          if [ "$image" == "xo" ] || [ "$image" == "xshrim/xo" ]; then
            imgsh="$image zsh $chroot"
          else
            imgsh="$image sh $chroot"
          fi

          cmd="docker run --rm -it $vol --network=container:$cid --pid=container:$cid --ipc=container:$cid $imgsh"

          execmd "$cmd" $haddr
        else
          echo "subcmd debug not fit for $kind"
        fi
        ;;
      *)
        usage
        exit 1
        ;;
      esac
    fi
  fi
}

function require() {
  for dep in $*; do
    if ! type $dep &>/dev/null; then
      echo "$dep required"
      exit 1
    fi
  done
}

function getip() {
  itfs=$(ip -j a|jq -r '.[].ifname')
  itfs=($itfs)

  ifnets=()
  for ((i = 0; i < ${#itfs[@]}; i++)); do
    itf=${itfs[$i]}
    itfi=$(ip -j a show dev $itf)
    status=$(echo $itfi|jq -r '.[].operstate')
    ether=$(echo $itfi|jq -r '.[].address')
    if [ -z "$ether" ]; then
      ether="NA"
    fi
    mtu=$(echo $itfi|jq -r '.[].mtu')
    inet=$(echo $itfi|jq -r '.[].addr_info[]|select(.family=="inet")|.local')
    inetprefix=$(echo $itfi|jq -r '.[].addr_info[]|select(.family=="inet")|.prefixlen')
    inetdyn=$(echo $itfi|jq -r '.[].addr_info[]|select(.family=="inet")|.dynamic')
    if [ -z "$inetdyn" ]; then
      inetassign=""
    else
      if [ "$inetdyn" == "true" ]; then
        inetassign="D"
      else
        inetassing="S"
      fi
    fi
    if [ -n "$inetprefix" ]; then
      inet=$inet/$inetprefix
    fi
    if [ -n "$inetassign" ]; then
      inet=$inet"#$inetassign"
    fi
    if [ -z "$inet" ]; then
      inet="NA"
    fi
    inet6=$(echo $itfi|jq -r '.[].addr_info[]|select(.family=="inet6")|.local')
    inet6prefix=$(echo $itfi|jq -r '.[].addr_info[]|select(.family=="inet6")|.prefixlen')
    inet6dyn=$(echo $itfi|jq -r '.[].addr_info[]|select(.family=="inet6")|.dynamic')
    if [ -z "$inet6dyn" ]; then
      inet6assign=""
    else
      if [ "$inet6dyn" == "true" ]; then
        inet6assign="D"
      else
        inet6assing="S"
      fi
    fi
    if [ -n "$inet6prefix" ]; then
      inet6=$inet6/$inet6prefix
    fi
    if [ -n "$inet6assign" ]; then
      inet6=$inet6"#$inet6assign"
    fi
    if [ -z "$inet6" ]; then
      inet6="NA"
    fi
    item="$itf: $inet $inet6 $ether $mtu $status"
    ifnets[$i]="$item"
  done

  for ((i = 0; i < ${#ifnets[@]}; i++)); do
    if [ "$1" == "ipp" ]; then
      echo ${ifnets[$i]} | awk '{printf "%-20s\t%-20s\t%-30s\t%-18s\t%-6s\t%-8s\n", $1, $2, $3, $4, $5, $6}'|grep -iE '^(en|wl|ww|eth)'|grep "$2"
    elif [ "$1" == "ipa" ]; then
      echo ${ifnets[$i]} | awk '{printf "%-20s\t%-20s\t%-30s\t%-18s\t%-6s\t%-8s\n", $1, $2, $3, $4, $5, $6}'|grep "$2"
    else
      echo ${ifnets[$i]} | awk '{printf "%-20s\t%-20s\t%-30s\t%-18s\t%-6s\t%-8s\n", $1, $2, $3, $4, $5, $6}'|grep "$1"
    fi
  done
}

function dockerpush() {
  require docker
  # lrepo=${1%/*}
  limg=${1##*/}
  rrepo=${2%/*}
  rlib=${2#*/}

  if [ "$rlib" == "" ] || [ "$rlib" == "$rrepo" ]; then
    if [[ "$rrepo" =~ "." ]]; then
      rlib="library"
    else
      rlib=$rrepo
      rrepo="docker.io"
    fi
  fi

  docker tag $1 $rrepo/$rlib/$limg
  docker push $rrepo/$rlib/$limg
  docker rmi -f $rrepo/$rlib/$limg
}

function docmd() {
  eval "$*"
}

function lexecmd() {
  ecmd=$1
  ipaddr=$2

  if [ "$ipaddr" == "" ]; then
    docmd $ecmd
  else
    ipd=${ipaddr%.*}
    ipr=${ipaddr##*.}

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    ipasswd=""
    iuser=""
    if [ -n "$passwd" ]; then
      ipasswd="-p $passwd"
    fi
    if [ -n "$user" ]; then
      iuser="$user@"
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      echo "[*] $cip"
      if [ -n "$passwd" ] && type sshpass &>/dev/null; then
        sshpass $ipasswd $ecmd $iuser$cip
      else
        docmd $ecmd $iuser$cip
      fi
    done
  fi
}

function execmd() {
  ecmd=$1
  ipaddr=$2

  if [ "$ipaddr" == "" ]; then
    docmd $ecmd
  else
    ipd=${ipaddr%.*}
    ipr=${ipaddr##*.}

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    ipasswd=""
    iport=""
    iuser=""
    if [ -n "$passwd" ]; then
      ipasswd="-p $passwd"
    fi
    if [ -n "$port" ]; then
      iport="-p $port"
    fi
    if [ -n "$user" ]; then
      iuser="$user@"
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      echo "[*] $cip"
      if [ -n "$passwd" ] && type sshpass &>/dev/null; then
        sshpass $ipasswd ssh -t $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout $iuser$cip "$ecmd"
      else
        ssh -t $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout $iuser$cip "$ecmd"
      fi
    done
  fi
}

function remotecp() {
  paths=$1
  ipaddr=$2

  if [ "$paths" == "" ] || [ "$ipaddr" == "" ]; then
    return
  else
    #     if [ -z "$user" ]; then
    #       user="root"
    #     fi
    #     if [ -z "$passwd" ]; then
    #       passwd="root"
    #     fi

    lpath=${paths%:*}
    rpath=${paths##*:}

    ipd=${ipaddr%.*}
    ipr=${ipaddr##*.}

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    ipasswd=""
    iport=""
    iuser=""
    if [ -n "$passwd" ]; then
      ipasswd="-p $passwd"
    fi
    if [ -n "$port" ]; then
      iport="-P $port"
    fi
    if [ -n "$user" ]; then
      iuser="$user@"
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      echo "[*] $cip"
      if [ -n "$passwd" ] && type sshpass &>/dev/null; then
        sshpass $ipasswd scp $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout -r $lpath $iuser$cip:$rpath
      else
        scp -t -$iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout -r$lpath $iuser$cip:$rpath
      fi
    done
  fi
}

function genssl() {
  case "$1" in
  -h | --help)
    gensslhelp
    exit
    ;;
  esac

  if [[ $1 == '' ]]; then
    gensslhelp
    exit
  fi

  CMDOPTS="$*"
  for OPTS in $CMDOPTS; do
    key=$(echo ${OPTS} | awk -F"=" '{print $1}')
    value=$(echo ${OPTS} | awk -F"=" '{print $2}')
    case "$key" in
    --ssl-domain) SSL_DOMAIN=$value ;;
    --ssl-trusted-ip) SSL_TRUSTED_IP=$value ;;
    --ssl-trusted-domain) SSL_TRUSTED_DOMAIN=$value ;;
    --ssl-size) SSL_SIZE=$value ;;
    --ssl-date) SSL_DATE=$value ;;
    --ca-date) CA_DATE=$value ;;
    --ssl-cn) CN=$value ;;
    --ca-reuse) CA_REUSE=$value ;;
    --ca-key) CA_KEY=$value ;;
    --ca-cert) CA_CERT=$value ;;
    esac
  done

  # CA相关配置
  CA_DATE=${CA_DATE:-3650}
  CA_KEY=${CA_KEY:-cakey.pem}
  CA_CERT=${CA_CERT:-cacerts.pem}
  CA_DOMAIN=localhost
  CA_REUSE=${CA_REUSE:-false}

  # ssl相关配置
  SSL_CONFIG=${SSL_CONFIG:-$PWD/openssl.cnf}
  SSL_DOMAIN=${SSL_DOMAIN:-localhost}
  SSL_DATE=${SSL_DATE:-3650}
  SSL_SIZE=${SSL_SIZE:-2048}

  ## 国家代码(2个字母的代号),默认CN;
  CN=${CN:-CN}

  SSL_KEY=$SSL_DOMAIN.key
  SSL_CSR=$SSL_DOMAIN.csr
  SSL_CERT=$SSL_DOMAIN.crt

  echo -e "\033[32m ---------------------------- \033[0m"
  echo -e "\033[32m       | 生成 SSL Cert |       \033[0m"
  echo -e "\033[32m ---------------------------- \033[0m"

  if [[ -e ./${CA_KEY} ]]; then
    if [[ ${CA_REUSE} == true ]]; then
      echo -e "\033[32m ====> 1. 复用已存在CA私钥 \033[0m"
    else
      echo -e "\033[32m ====> 1. 发现已存在CA私钥，备份"${CA_KEY}"为"${CA_KEY}"-bak，然后重新创建 \033[0m"
      mv ${CA_KEY} "${CA_KEY}"-bak
      openssl genrsa -out ${CA_KEY} ${SSL_SIZE}
    fi
  else
    echo -e "\033[32m ====> 1. 生成新的CA私钥 ${CA_KEY} \033[0m"
    openssl genrsa -out ${CA_KEY} ${SSL_SIZE}
  fi

  if [[ -e ./${CA_CERT} ]]; then
    if [[ ${CA_REUSE} == true ]]; then
      echo -e "\033[32m ====> 1. 复用已存在CA证书 \033[0m"
    else
      echo -e "\033[32m ====> 2. 发现已存在CA证书，先备份"${CA_CERT}"为"${CA_CERT}"-bak，然后重新创建 \033[0m"
      mv ${CA_CERT} "${CA_CERT}"-bak
      openssl req -x509 -sha256 -new -nodes -key ${CA_KEY} -days ${CA_DATE} -out ${CA_CERT} -subj "/C=${CN}/CN=${CA_DOMAIN}"
    fi
  else
    echo -e "\033[32m ====> 2. 生成新的CA证书 ${CA_CERT} \033[0m"
    openssl req -x509 -sha256 -new -nodes -key ${CA_KEY} -days ${CA_DATE} -out ${CA_CERT} -subj "/C=${CN}/CN=${CA_DOMAIN}"
  fi

  echo -e "\033[32m ====> 3. 生成Openssl配置文件 ${SSL_CONFIG} \033[0m"
  cat >${SSL_CONFIG} <<EOM
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, serverAuth
EOM

  if [[ -n ${SSL_TRUSTED_IP} || -n ${SSL_TRUSTED_DOMAIN} ]]; then
    cat >>${SSL_CONFIG} <<EOM
subjectAltName = @alt_names
[alt_names]
EOM
    IFS=","
    dns=(${SSL_TRUSTED_DOMAIN})
    dns+=(${SSL_DOMAIN})
    for i in "${!dns[@]}"; do
      echo DNS.$((i + 1)) = ${dns[$i]} >>${SSL_CONFIG}
    done

    if [[ -n ${SSL_TRUSTED_IP} ]]; then
      ip=(${SSL_TRUSTED_IP})
      for i in "${!ip[@]}"; do
        echo IP.$((i + 1)) = ${ip[$i]} >>${SSL_CONFIG}
      done
    fi
  fi

  echo -e "\033[32m ====> 4. 生成服务SSL KEY ${SSL_KEY} \033[0m"
  openssl genrsa -out ${SSL_KEY} ${SSL_SIZE}

  echo -e "\033[32m ====> 5. 生成服务SSL CSR ${SSL_CSR} \033[0m"
  openssl req -sha256 -new -key ${SSL_KEY} -out ${SSL_CSR} -subj "/C=${CN}/CN=${SSL_DOMAIN}" -config ${SSL_CONFIG}

  echo -e "\033[32m ====> 6. 生成服务SSL CERT ${SSL_CERT} \033[0m"
  openssl x509 -sha256 -req -in ${SSL_CSR} -CA ${CA_CERT} \
    -CAkey ${CA_KEY} -CAcreateserial -out ${SSL_CERT} \
    -days ${SSL_DATE} -extensions v3_req \
    -extfile ${SSL_CONFIG}

  echo -e "\033[32m ====> 7. 证书制作完成 \033[0m"
  echo
  echo -e "\033[32m ====> 8. 以YAML格式输出结果 \033[0m"
  echo "----------------------------------------------------------"
  echo "ca_key: |"
  cat $CA_KEY | sed 's/^/  /'
  echo
  echo "ca_cert: |"
  cat $CA_CERT | sed 's/^/  /'
  echo
  echo "ssl_key: |"
  cat $SSL_KEY | sed 's/^/  /'
  echo
  echo "ssl_csr: |"
  cat $SSL_CSR | sed 's/^/  /'
  echo
  echo "ssl_cert: |"
  cat $SSL_CERT | sed 's/^/  /'
  echo

  echo -e "\033[32m ====> 9. 附加CA证书到Cert文件 \033[0m"
  cat ${CA_CERT} >>${SSL_CERT}
  echo "ssl_cert: |"
  cat $SSL_CERT | sed 's/^/  /'
  echo

  echo -e "\033[32m ====> 10. 重命名服务证书 \033[0m"
  echo "cp ${SSL_DOMAIN}.key tls.key"
  cp ${SSL_DOMAIN}.key tls.key
  echo "cp ${SSL_DOMAIN}.crt tls.crt"
  cp ${SSL_DOMAIN}.crt tls.crt
}

function printSample() {
  local dockerSample="
FROM alpine:latest

LABEL maintainer='xshrim@yeah.net'

RUN set -ex && apk update && apk upgrade && apk add --no-cache bash

WORKDIR /root/

ADD motd /etc/motd
COPY static /root/static

#RUN mkdir /lib64 && ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2 && apk add -U util-linux && apk add -U tzdata && cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  # 解决go语言程序无法在alpine执行的问题和syslog不支持udp的问题和时区问题

EXPOSE 22 445/tcp

CMD [\"sh\",\"/root/run.sh\"]
"

  local secretSample="
apiVersion: v1
kind: Secret
metadata:
  name: myregistrykey
  namespace: awesomeapps
data:
  .dockerconfigjson: UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==
type: kubernetes.io/dockerconfigjson
"

  local configmapSample="
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config
  namespace: default
data:
  my.yaml: |
    name: tom
    light.weight: baby
    gym: muscle
"

  local rbacSample="
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: role-grantor
rules:
- apiGroups: [\"rbac.authorization.k8s.io\"]
  resources: [\"rolebindings\"]
  verbs: [\"create\"]
- apiGroups: [\"rbac.authorization.k8s.io\"]
  resources: [\"clusterroles\"]
  verbs: [\"bind\"]
  resourceNames: [\"admin\",\"edit\",\"view\"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: role-grantor-binding
  namespace: user-1-namespace
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: role-grantor
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: ServiceAccount
  name: grantor
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    foo: bar
  name: grantor
  namespace: default
"

  local storageSample="
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: nas
parameters:
  archiveOnDelete: \"true\"
provisioner: cluster.local/nas-client-provisioner
reclaimPolicy: Delete
volumeBindingMode: Immediate
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: nfs-pv
  labels:
    release: stable
spec:
  capacity:
    storage: 1Gi
  accessModes:
  - ReadWriteMany
  nfs:
    server: 10.10.10.10
    path: /nas
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: nfs-pvc
spec:
  accessModes:
  - ReadWriteMany
  selector:
    matchLabels:
      release: stable
  storageClassName: manual
  resources:
    requests:
      storage: 1Gi
"

  local serviceSample="
apiVersion: v1
kind: Service
metadata:
  name: websvc
  namespace: default
  labels:
    run: nginx
spec:
  type: clusterIP
  clusterIP: None
  ports:
  - name: webport
    port: 80
    protocol: TCP
    targetPort: 80
    nodePort: 30300
  selector:
    run: nginx
---
apiVersion: v1
kind: Endpoints
metadata:
  name: websvc
subsets:
- addresses:
  - ip: 25.10.10.10
  ports:
  - port: 80
"

  local ingressSample="
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/backend-protocol: HTTPS
    nginx.ingress.kubernetes.io/proxy-body-size: 1000M
    nginx.ingress.kubernetes.io/ssl-redirect: \"false\"
    nginx.ingress.kubernetes.io/rewrite-target: /$1
    nginx.ingress.kubernetes.io/cors-allow-headers: DNT,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,Accept,Origin,Referer
    nginx.ingress.kubernetes.io/cors-allow-methods: GET, PUT, POST, DELETE, PATCH
    nginx.ingress.kubernetes.io/enable-cors: \"true\"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      more_set_headers \"X-Frame-Options: ALLOW-FROM *\";
  name: kubernetes
  namespace: default
spec:
  tls:
    - hosts:
        - foo.bar.com
      secretName: ingress-tls
  rules:
    - host: foo.bar.com
      http:
        paths:
          - backend:
              serviceName: kubernetes
              servicePort: 443
            path: /region/(.*)
"

  local podSample="
apiVersion: v1
kind: Pod
metadata:
  name: xo
  namespace: default
  labels:
    app: xo
  annotations:
    alpha.istio.io/sidecar: ignore
spec:
  nodeSelector:
    disk: ssd
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/project
            operator: In
            values:
            - demo
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: security
            operator: In
            values:
            - S1
        topologyKey: failure-domain.beta.kubernetes.io/zone
    tolerations:
    - key: key
      operator: Equal
      value: value
      effect: NoSchedule
  dnsPolicy: ClusterFirst
  restartPolicy: Always
  schedulerName: default-scheduler
  shareProcessNamespace: false
  hostNetwork: false
  securityContext:
    runAsUser: 1000
  serviceAccountName: foo
  automountServiceAccountToken: true
  hostAliases:
  - ip: \"127.0.0.1\"
    hostnames:
    - \"foo.local\"
    - \"bar.local\"
  volumes:
  - name: storage
    persistentVolumeClaim:
      claimName: mysql-pv-claim
  containers:
  - name: xo
    image: registry.io/library/xo
    imagePullPolicy: IfNotPresent
    imagePullSecrets:
    - name: regcred
    env:
    - name: FOO
      value: bar
    - name: SPECIAL_KEY
      valueFrom:
        configMapKeyRef:
          name: special-config
          key: special.how
    command: [\"/bin/sh\"]
    args: [\"-c\", \"while true; do echo hello; sleep 10;done\"]
    ports:
    - containerPort: 8080
      protocol: TCP
    resources: 
      limits:
        cpu: 100m
        memory: 128M
    volumeMounts:
    - name: storage
      mountPath: /data
      subPath: config
    lifecycle:
      postStart:
        exec:
          command: [\"/bin/sh\", \"-c\", \"echo Hello\"]
    readinessProbe:
      httpGet:
        path: /
        port: 8080
        initialDelaySeconds: 5
        periodSeconds: 5
        successThreshold: 1
"

  local deploySample="
apiVersion: apps/v1
kind: Deployment
metadata:
  name: xo
  namespace: default
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 25%
      maxSurge: 1
  selector:
    matchLabels:
      app: xo
  template:
    metadata:
      labels:
        app: xo
    annotations:
      alpha.istio.io/sidecar: ignore
    spec:
      nodeSelector:
        disk: ssd
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/project
                operator: In
                values:
                - demo
        podAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: security
                operator: In
                values:
                - S1
            topologyKey: failure-domain.beta.kubernetes.io/zone
        tolerations:
        - key: key
          operator: Equal
          value: value
          effect: NoSchedule
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      shareProcessNamespace: false
      hostNetwork: false
      securityContext:
        runAsUser: 1000
      serviceAccountName: foo
      automountServiceAccountToken: true
      hostAliases:
      - ip: \"127.0.0.1\"
        hostnames:
        - \"foo.local\"
        - \"bar.local\"
      volumes:
      - name: storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
      containers:
      - name: xo
        image: registry.io/library/xo
        imagePullPolicy: IfNotPresent
        imagePullSecrets:
        - name: regcred
        env:
        - name: FOO
          value: bar
        - name: SPECIAL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        command: [\"/bin/sh\"]
        args: [\"-c\", \"while true; do echo hello; sleep 10;done\"]
        ports:
        - containerPort: 8080
          protocol: TCP
        resources: 
          limits:
            cpu: 100m
            memory: 128M
        volumeMounts:
        - name: storage
          mountPath: /data
          subPath: config
        lifecycle:
          postStart:
            exec:
              command: [\"/bin/sh\", \"-c\", \"echo Hello\"]
        readinessProbe:
          httpGet:
            path: /
            port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            successThreshold: 1
"

  local daemonsetSample="
apiVersion: apps/v1
kind: DaemonSet
metadata:
  annotations:
    describe: hello
  labels:
    service_name: demo
  name: demo
  namespace: default
spec:
  selector:
    matchLabels:
      name: demo
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: foo
    spec:
      tolerations:
      - effect: NoSchedule
        operator: Exists
      volumes:
      - name: storage
        nfs:
          server: 127.0.0.1
          path: /nas
      containers:
      - name: demo
        image: registry.io/library/demo
        imagePullPolicy: Always
        env:
        - name: MODE
          value: restart
        resources:
          requests:
            cpu: 256m
            memory: 512Mi
        volumeMounts:
        - mountPath: /data
          name: storage
"

  local statefulsetSample="
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: demo
  name: demo
  namespace: default
spec:
  replicas: 1
  podManagementPolicy: OrderedReady
  selector:
    matchLabels:
      app: demo
  updateStrategy:
    rollingUpdate:
      partition: 0
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      name: mydata
    spec:
      accessModes: [\"ReadWriteOnce\"]
      resources:
        requests:
          storage: 5Gi
  template:
    metadata:
      labels:
        app: demo
    spec:
      initContainers:
      - name: init
        command:
        - /bin/bash
        - -c
        - rm -Rf /data
        image: registry.io/library/busybox
        imagePullPolicy: IfNotPresent
        resources: {}
        volumeMounts:
        - mountPath: /var/lib/data
          name: mydata
      containers:
      - name: demo
        envFrom:
        - secretRef:
            name: my-secret
        image: registry.io/library/demo
        imagePullPolicy: IfNotPresent
        resources: {}
        volumeMounts:
        - mountPath: /var/lib/data
          name: mydata
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
"

  local jobSample="
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    job-name: pi
  name: pi
  namespace: default
spec:
  backoffLimit: 4
  completions: 1
  parallelism: 1
  selector:
    matchLabels:
      app: pi
  template:
    metadata:
      labels:
        app: pi
        job-name: pi
    spec:
      containers:
      - name: pi
        command:
        - perl
        - -Mbignum=bpi
        - -wle
        - print bpi(2000)
        image: perl
        imagePullPolicy: Always
        resources: {}
      dnsPolicy: ClusterFirst
      restartPolicy: Never
      schedulerName: default-scheduler
      securityContext: {}
"

  local cronjobSample="
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: \"*/1 * * * *\"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            args:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster
          restartPolicy: OnFailure
"

  local networkpolicySample="
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
    - namespaceSelector:
        matchLabels:
          project: myproject
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 6379
  egress:
  - to:
    - ipBlock:
        cidr: 10.0.0.0/24
    ports:
    - protocol: TCP
      port: 5978
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
spec:
  podSelector: {}
  policyTypes:
  - Ingress
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all-ingress
spec:
  podSelector: {}
  ingress:
  - {}
  policyTypes:
  - Ingress
"

  case $1 in
  "docker")
    echo "$dockerSample"
    ;;
  "secret")
    echo "$secretSample"
    ;;
  "cm" | "configmap")
    echo "$configmapSample"
    ;;
  "role" | "rb" | "sa" | "rolebinding" | "serviceaccount" | "rbac")
    echo "$rbacSample"
    ;;
  "pv" | "pvc" | "sc" | "storageclass")
    echo "$storageSample"
    ;;
  "svc" | "service")
    echo "$serviceSample"
    ;;
  "ing" | "ingress")
    echo "$ingressSample"
    ;;
  "pod")
    echo "$podSample"
    ;;
  "deploy" | "deployment")
    echo "$deploySample"
    ;;
  "sts" | "statefulset")
    echo "$statefulsetSample"
    ;;
  "ds" | "daemonset")
    echo "$daemonsetSample"
    ;;
  "job")
    echo "$jobSample"
    ;;
  "cj" | "cronjob")
    echo "$cronjobSample"
    ;;
  "np" | "networkpolicy")
    echo "$networkpolicySample"
    ;;
  esac
}

main "$@"
