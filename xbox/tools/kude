#!/bin/bash

kubecfg=""
image=xo
port=22
timeout=60
user=root
#passwd=root
idx=0
amount=""
kwd=""
kind="pod"
context=""
args=""
chroot=""
localrun=0
savepath=""
vol=""

mandatory=()

function usage() {
  echo "**USAGE**:
  kude <command> [<options>] [<object>]

**COMMANDS**:
  hp,help                   打印命令帮助
  git                      git运行git命令
  g,go                     运行go命令
  lg,lgo                   Linux环境下禁用CGO的go命令
  h,helm                   运行helm命令
  d,docker                 运行docker命令
  k,kube,kubectl           运行kubectl命令
  c,cmd                    运行linux命令
  scp                      分发本机文件
  gi                       git一键提交并上传
  ghp,ghelp                查看go命令帮助
  khp,khelp                查看kubectl命令帮助
  dhp,dhelp                查看docker命令帮助
  dr,drun                  运行容器
  dt,dtmp                  运行临时容器
  db,dbd                   构建docker镜像
  dg,dtg,dtag              为镜像打标签
  dq,dps,dlist             查看容器列表
  di,dimg                  查看镜像列表
  dn,dnet                  查看容器网络列表
  dv,dvol                  查看容器卷列表
  dd,drm                   删除容器
  do,drmi                  删除镜像
  dh,dhist                 查看镜像构建历史
  ds,dpush                 推送镜像
  dl,dpull                 拉取镜像
  da,daddr                 查看容器网络信息
  de,denv                  查看容器环境变量
  dc,dcmd                  查看容器运行命令
  dp,dport                 查看容器端口映射
  dm,dmnt                  查看容器卷挂载
  dw,dcc                   删除所有已退出的容器
  dx,dic                   删除所有未使用的镜像
  dy,dvc                   删除所有未使用的容器卷
  dz,dnc                   删除所有未使用的网络
  cf,cfind                 查找当前目录下包含指定关键字的文件
  df,dfind                 查找容器配置中包含指定关键字的容器
  kf,kfind                 查找资源中包含指定关键字的资源
  cfg,config               查看kubeconfig配置
  dry,dryrun               模拟执行kubectl命令
  ap,apl,apply             执行kubectl apply命令
  n,new,create             执行kubectl create命令
  r,run                    执行kubectl run命令
  b,rbac                   查看rbac结构图
  a,all                    查看指定命名空间下所有资源
  ro,rollout               执行kubectl rollout命令
  au,auth                  执行kubectl auth命令
  pr,proxy                 开启kube apiserver本地代理
  l,log                    查看容器日志
  lf,logf                  实时查看容器日志
  i,insp,inspect           查看容器信息
  g,get                    查看k8s资源信息
  s,desc,describe          查看k8s资源详细信息
  wa,watch                 监视指定k8s资源状态
  w,wide                   查看k8s资源更多信息
  wl,wlabel                查看k8s资源包括label在内的更多信息
  y,yaml                   以yaml格式查看k8s资源信息
  j,json                   以json格式查看k8s资源信息
  tp, top                  查看node或pod资源占用
  p,patch                  为k8s资源打补丁
  rm,del,delete            删除k8s资源
  e,exe,exec               在pod中执行命令
  ie,iexe,iexec            在pod中交互式执行命令
  at,attach                加入pod的命名空间
  cp,copy                  在本地和pod之间复制文件
  pf,forward,port-forward  将本地端口映射到pod端口实现端口转发
  x,deb,debug              运行调试容器对pod进行调试

**OPTIONS**:
  -a [100] log显示条数
  -c [context] kubernetes连接上下文(可选)
  -d [savedir] rbac结构图保存目录(可选)
  -f [./kube/config] kubeonfig文件路径(可选)
  -i [0] 匹配pod内容器index(可选)
  -k [kind] k8s资源类型
  -m [xo] 自定义调试工具容器(可选)
  -n [default] 查询的k8s命名空间(可选)
  -o [host] 指定目标主机ip
  -p [22] 目标主机ssh端口(可选)
  -s [admin123] 目标主机ssh密码(可选)
  -t [60] 目标主机ssh连接超时时间(可选)
  -u [root] 目标主机ssh账号(可选)
  -w [kwd] 过滤关键字
  -l 配合cmd本机执行命令
  -r 调试容器中是否需要chroot到目标容器的文件系统
  -v 调试容器中是否需要挂载目标主机的docker.sock文件
  -h 使用说明
"
  if [ "$1" != "simple" ]; then
    echo "
**REFERENCES**:
# Linux: https://community.linuxmint.com/tutorial/view/244 https://man.linuxde.net/
# Docker: https://docs.docker.com/engine/reference/commandline/cli/
# Kubectl: https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands

**EXAMPLES**:
# 直接执行docker或kubectl命令
kude d ps -a     #相当于docker ps -a
kude k get pod   #相当于kubectl get pod

# 查看docker或kubectl命令帮助
kude dhp run
kude khp get

# 进行docker镜像推送并删除临时tag
kude ds xshrim/xo foo.bar.com/xshrim

# 查看docker容器运行的命令
kude dc nginx

# 查看镜像构建历史
kude dh xshrim/xo

# 远程到目标主机执行命令
kude cmd 'ls /etc' 127.0.0.1 10.20.0.12-18
kude cmd -p 22 -s admin 'ls /etc' 127.0.0.1

# 执行本机命令
kude cmd 'scp test root@10.0.0.10:/root/test'

# 将本地文件分发到远程主机
./kude scp './foo:/root/bar' 10.20.0.12-18

# 获取Kubernetes RBAC结构图
kude b u demouser
kude rbac -n kube-system rolebinding

# 查看kubeconfig配置
kude cfg

# 执行kubectl apply命令
kude ap pod.yaml

# 开启kube-apiserver本地代理
kude pr 8443
kude pr 127.0.0.1:8443

# 查看容器日志
kude l nginx
kude lf nginx
kude lf -a 10 nginx
kude log -i 1 nginx

# 查看k8s资源详细信息
kude s nginx
kude desc -k deploy nginx

# 查找包含指定关键字的资源
kude -c acp-global -k sa -n default kf token-pfmd8

# 以yaml格式查看k8s资源信息
kude y nginx
kude yaml -k rs nginx

# 监视k8s资源状态
kude watch -k deploy nginx

# 为k8s资源打补丁
kude p -k deploy nginx '{"spec":{"replicas":2}}'

# 进入pod执行命令
kude e nginx -n default ls
kude ie nginx

# 在本地和pod之间复制文件
kude cp nginx :/foo ./foo
kude cp nginx -n default bar :/bar

# 将本地端口映射到pod端口实现端口转发
kude pf nginx 8000:80
kude -c minikube pf nginx -n default 8000:80

# 运行调试容器对pod内的指定容器进行调试
kude x nginx
kude debug -n xshrim -u root -p 22 -s admin123 -m netshoot nginx
"
  fi
}

function require() {
  for dep in $*; do
    if ! type $dep &>/dev/null; then
      echo "$dep required"
      exit 1
    fi
  done
}

function dockerpush() {
  require docker
  # lrepo=${1%/*}
  limg=${1##*/}
  rrepo=${2%/*}
  rlib=${2#*/}

  if [ "$rlib" == "" ] || [ "$rlib" == "$rrepo" ]; then
    if [[ "$rrepo" =~ "." ]]; then
      rlib="library"
    else
      rlib=$rrepo
      rrepo="docker.io"
    fi
  fi

  docker tag $1 $rrepo/$rlib/$limg
  docker push $rrepo/$rlib/$limg
  docker rmi -f $rrepo/$rlib/$limg
}

function docmd() {
  # lcmd=$1
  # if [ "$lcmd" == "dpush" ]; then
  #   dockerpush "${@:2}"
  # else
  #   $*
  # fi
  eval "$*"
}

function lexecmd() {
  ecmd=$1
  ipaddr=$2

  if [ "$ipaddr" == "" ]; then
    docmd $ecmd
  else
    #     if [ -z "$user" ]; then
    #       user="root"
    #     fi
    #     if [ -z "$passwd" ]; then
    #       passwd="root"
    #     fi

    ipd=${ipaddr%.*}
    ipr=${ipaddr##*.}

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    ipasswd=""
    iuser=""
    if [ -n "$passwd" ]; then
      ipasswd="-p $passwd"
    fi
    if [ -n "$user" ]; then
      iuser="$user@"
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      echo "[*] $cip"
      if [ -n "$passwd" ] && type sshpass &>/dev/null; then
        sshpass $ipasswd $ecmd $iuser$cip
      else
        docmd $ecmd $iuser$cip
      fi
    done
  fi
}

function execmd() {
  ecmd=$1
  ipaddr=$2

  if [ "$ipaddr" == "" ]; then
    docmd $ecmd
  else
    #     if [ -z "$user" ]; then
    #       user="root"
    #     fi
    #     if [ -z "$passwd" ]; then
    #       passwd="root"
    #     fi

    ipd=${ipaddr%.*}
    ipr=${ipaddr##*.}

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    ipasswd=""
    iport=""
    iuser=""
    if [ -n "$passwd" ]; then
      ipasswd="-p $passwd"
    fi
    if [ -n "$port" ]; then
      iport="-p $port"
    fi
    if [ -n "$user" ]; then
      iuser="$user@"
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      echo "[*] $cip"
      if [ -n "$passwd" ] && type sshpass &>/dev/null; then
        sshpass $ipasswd ssh -t $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout $iuser$cip "$ecmd"
      else
        ssh -t $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout $iuser$cip "$ecmd"
      fi
    done
  fi
}

function remotecp() {
  paths=$1
  ipaddr=$2

  if [ "$paths" == "" ] || [ "$ipaddr" == "" ]; then
    return
  else
    #     if [ -z "$user" ]; then
    #       user="root"
    #     fi
    #     if [ -z "$passwd" ]; then
    #       passwd="root"
    #     fi

    lpath=${paths%:*}
    rpath=${paths##*:}

    ipd=${ipaddr%.*}
    ipr=${ipaddr##*.}

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    ipasswd=""
    iport=""
    iuser=""
    if [ -n "$passwd" ]; then
      ipasswd="-p $passwd"
    fi
    if [ -n "$port" ]; then
      iport="-P $port"
    fi
    if [ -n "$user" ]; then
      iuser="$user@"
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      echo "[*] $cip"
      if [ -n "$passwd" ] && type sshpass &>/dev/null; then
        sshpass $ipasswd scp $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout -r $lpath $iuser$cip:$rpath
      else
        scp -t -$iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout -r$lpath $iuser$cip:$rpath
      fi
    done
  fi
}

# placeholder

if [ $1 == "g" ] || [ $1 == "go" ]; then
  require go
  shift
  go $*
elif [ $1 == "lg" ] || [ $1 == "lgo" ]; then
  require go
  shift
  CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go $*
elif [ $1 == "git" ]; then
  require git
  shift
  git $*
elif [ $1 == "h" ] || [ $1 == "helm" ]; then
  require helm
  shift
  helm $*
elif [ $1 == "d" ] || [ $1 == "docker" ]; then
  require docker
  shift
  docker $*
elif [ $1 == "k" ] || [ $1 == "kube" ] || [ $1 == "kubectl" ]; then
  require kubectl
  shift
  kubectl $*
elif [ $1 == "ghp" ] || [ $1 == "ghelp" ]; then
  require go
  shift
  go help $*
elif [ $1 == "dhp" ] || [ $1 == "dhelp" ]; then
  require docker
  shift
  docker $* --help
elif [ $1 == "khp" ] || [ $1 == "khelp" ]; then
  require kubectl
  shift
  kubectl $* --help
elif [ $1 == "dr" ] || [ $1 == "drun" ]; then
  require docker
  shift
  docker run $*
elif [ $1 == "dt" ] || [ $1 == "dtmp" ]; then
  require docker
  shift
  docker run -it --rm $*
elif [ $1 == "db" ] || [ $1 == "dbd" ]; then
  require docker
  shift
  docker build $*
elif [ $1 == "dg" ] || [ $1 == "dtg" ] || [ $1 == "dtag" ]; then
  require docker
  shift
  docker tag $*
else
  while [ $# -gt 0 ] && [[ "$1" != "--" ]]; do
    while getopts "a:c:d:f:i:k:m:n:o:p:s:t:u:w:hlrv" opt; do
      case $opt in
      a)
        amount="--tail $OPTARG"
        ;;
      c)
        context="--context $OPTARG"
        ;;
      d)
        savedir="$OPTARG"
        ;;
      f)
        kubecfg=$OPTARG
        ;;
      i)
        idx=$OPTARG
        ;;
      k)
        kind=$OPTARG
        ;;
      l)
        localrun=1
        ;;
      m)
        image=$OPTARG
        ;;
      n)
        namespace=$OPTARG
        ;;
      o)
        host="$OPTARG"
        ;;
      p)
        port=$OPTARG
        ;;
      r)
        chroot="-c 'chroot /proc/1/root/'"
        ;;
      s)
        passwd=$OPTARG
        ;;
      t)
        timeout=$OPTARG
        ;;
      u)
        user=$OPTARG
        ;;
      v)
        vol="-v /var/run/docker.sock:/var/run/docker.sock"
        ;;
      w)
        kwd=$OPTARG
        ;;
      h)
        usage
        exit 0
        ;;
      \?)
        echo "Invalid option: -$OPTARG" >&2
        exit 1
        ;;
      esac
    done

    shift $((OPTIND - 1))

    while [ $# -gt 0 ] && (! [[ "$1" =~ ^- ]] || [[ "$1" =~ ^-- ]]); do
      mandatory=("${mandatory[@]}" "$1")
      shift
    done
  done

  if [ "$1" == "--" ]; then
    shift
    mandatory=("${mandatory[@]}" "$@")
  fi

  if ! [[ "${mandatory[0]}" =~ ^- ]]; then
    subcmd=${mandatory[0]}
    mandatory=("${mandatory[@]:1}")
  fi

  if [ -z $subcmd ]; then
    usage simple
    exit 1
  fi

  kc=""
  if [ -n "$kubecfg" ]; then
    kc="--kubeconfig $kubecfg"
  fi

  if [ -z "$namespace" ]; then
    ns="--all-namespaces"
  else
    ns="-n $namespace"
  fi

  if [ "$subcmd" == "hp" ]; then
    usage simple
    exit 0
  elif [ "$subcmd" == "help" ]; then
    usage
    exit 0
  elif [ "$subcmd" == "c" ] || [ "$subcmd" == "cmd" ]; then
    if [ ${#mandatory[@]} -gt 0 ]; then
      cmd=${mandatory[0]}
      if [ ${#mandatory[@]} -eq 1 ]; then
        execmd "$cmd"
      else
        for ip in ${mandatory[@]:1}; do
          if [ $localrun -eq 0 ]; then
            execmd "$cmd" $ip
          else
            lexecmd "$cmd" $ip
          fi
        done
      fi
    else
      echo "error: need arguments"
      exit 1
    fi
  elif [ "$subcmd" == "scp" ]; then
    if [ ${#mandatory[@]} -gt 0 ]; then
      cppaths=${mandatory[0]}
      if [ ${#mandatory[@]} -eq 1 ]; then
        remotecp "$cppaths"
      else
        for ip in ${mandatory[@]:1}; do
          remotecp "$cppaths" $ip
        done
      fi
    else
      echo "error: need arguments"
      exit 1
    fi
  elif [ "$subcmd" == "gi" ]; then
    require git
    cmsg="update"
    if [ ${#mandatory[@]} -gt 0 ]; then
      cmsg=${mandatory[*]}
    fi
    git add -A .
    git commit -m "$cmsg"
    git push
  elif [ "$subcmd" == "dq" ] || [ "$subcmd" == "dps" ] || [ "$subcmd" == "dlist" ]; then
    cmd="docker ps -a"
    if [ ${#mandatory[@]} -eq 0 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "di" ] || [ "$subcmd" == "dimg" ]; then
    cmd="docker image ls"
    if [ ${#mandatory[@]} -eq 0 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dn" ] || [ "$subcmd" == "dnet" ]; then
    cmd="docker network ls"
    if [ ${#mandatory[@]} -eq 0 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dv" ] || [ "$subcmd" == "dvol" ]; then
    cmd="docker volume ls"
    if [ ${#mandatory[@]} -eq 0 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dw" ] || [ "$subcmd" == "dcc" ]; then
    cmd="docker rm $(docker ps -qaf 'status=exited')"
    if [ ${#mandatory[@]} -eq 0 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dx" ] || [ "$subcmd" == "dic" ]; then
    cmd="docker image prune -a"
    if [ ${#mandatory[@]} -eq 0 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dy" ] || [ "$subcmd" == "dvc" ]; then
    cmd="docker volume prune"
    if [ ${#mandatory[@]} -eq 0 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dz" ] || [ "$subcmd" == "dnc" ]; then
    cmd="docker network prune"
    if [ ${#mandatory[@]} -eq 0 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "ds" ] || [ "$subcmd" == "dpush" ]; then
    require docker
    if [ ${#mandatory[@]} -gt 0 ]; then
      imgname=${mandatory[0]%:*}
      imgtag=${mandatory[0]##*:}
      if [ $imgname == $imgtag ]; then
        imgtag=""
      fi
      #       if [ -z $imgtag ] || [ $imgtag == "" ]; then
      #         imgtag="latest"
      #       fi
      #     if [ $(docker images|grep $imgname|awk '{print $2}'|grep $imgtag|wc -l) -eq 0 ]; then
      if [ -z $imgtag ] && [ $(docker images | grep $imgname | wc -l) -gt 1 ]; then
        #         docker pull $imgname:$imgtag
        echo "====== More than one image ======"
        imgs=$(docker images | grep $imgname | awk '{print $1":"$2}')
        SIFS=$IFS
        IFS=$'\n'
        imgs=($imgs)
        IFS=$SIFS
        for ((i = 0; i < ${#imgs[@]}; i++)); do
          echo "$i: ${imgs[$i]}"
        done
        imgtag="latest"
        echo "-1: pull $imgname:$imgtag"
        read -p "====== select one with number[0]: " iidx
        if [ -z $iidx ]; then
          iidx=0
        fi
        if [ $iidx -eq -1 ]; then
          docker pull $imgname:$imgtag
          irs=$imgname:$imgtag
        else
          irs=${imgs[$iidx]}
        fi
        llib=${irs%/*}
        limg=${irs##*/}
      elif [ $(docker images | grep $imgname | wc -l) -eq 0 ]; then
        pimg=$imgname:latest
        docker pull $pimg
        llib=${pimg%/*}
        limg=${pimg##*/}
      else
        if [ -z $imgtag ]; then
          imgtag="latest"
        fi
        pimg=$imgname:$imgtag
        llib=${pimg%/*}
        limg=${pimg##*/}
      fi

      if [ $llib == $limg ]; then
        llib=""
      fi

      if [ ${#mandatory[@]} -gt 1 ]; then
        rrepo=${mandatory[1]%%/*}
        rlib=${mandatory[1]#*/}
      fi

      rimg=${rlib#*/}
      rlib=${rlib%%/*}

      if [ "$rimg" == "$rlib" ]; then
        rimg=""
      fi

      if [ "$rlib" == "" ] || [ "$rlib" == "$rrepo" ]; then
        if [[ "$rrepo" =~ "." ]]; then
          rlib="library"
        else
          rlib=$rrepo
          rrepo="docker.io"
        fi
      fi

      if [ -z "$rlib" ]; then
        if [ -n "$llib" ]; then
          rlib=$llib
        else
          rlib="library"
        fi
      fi
      if [ -z "$rrepo" ]; then
        rrepo="docker.io"
      fi

      if [ -z $llib ]; then
        simg=$limg
      else
        simg=$llib/$limg
      fi

      if [ "$rimg" != "$limg" ] && [ -n $rimg ] && [ "$rimg" != "" ]; then
        limg=$rimg
      fi

      docker tag $simg $rrepo/$rlib/$limg
      docker push $rrepo/$rlib/$limg
      if [ "$rrepo" != "docker.io" ]; then
        docker rmi -f $rrepo/$rlib/$limg
      fi
    else
      echo "error: need arguments"
    fi
  elif [ "$subcmd" == "dl" ] || [ "$subcmd" == "dpull" ]; then
    cmd="docker pull ${mandatory[0]}"
    if [ ${#mandatory[@]} -eq 1 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]:1}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dd" ] || [ "$subcmd" == "drm" ]; then
    cmd="docker rm -f ${mandatory[0]}"
    if [ ${#mandatory[@]} -eq 1 ]; then
      require docker
      if [ $(docker ps -a | grep ${mandatory[0]} | wc -l) -lt 2 ]; then
        cmd="docker rm -f $(docker ps -a | grep ${mandatory[0]} | awk '{print $1}')"
        execmd "$cmd"
      else
        echo "====== More than one container ======"
        conts=$(docker ps -a --format 'table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep ${mandatory[0]})
        SIFS=$IFS
        IFS=$'\n'
        conts=($conts)
        IFS=$SIFS
        for ((i = 0; i < ${#conts[@]}; i++)); do
          echo "$i: ${conts[$i]}"
        done
        echo "-1: ALL"
        read -p "====== select one with number[0]: " dcidx
        if [ -z $dcidx ]; then
          dcidx=0
        fi
        if [ $dcidx -eq -1 ]; then
          cmd="docker rm -f $(docker ps -a | grep ${mandatory[0]} | awk '{print $1}')"
          execmd "$cmd"
        else
          cmd="docker rm -f $(echo ${conts[$dcidx]} | awk '{print $1}')"
          execmd "$cmd"
        fi
      fi
    else
      for ip in ${mandatory[@]:1}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "do" ] || [ "$subcmd" == "drmi" ]; then
    cmd="docker rmi -f ${mandatory[0]}"
    if [ ${#mandatory[@]} -eq 1 ]; then
      require docker
      if [ $(docker images | grep ${mandatory[0]} | wc -l) -lt 2 ]; then
        cmd="docker rmi -f $(docker images | grep ${mandatory[0]} | awk '{print $1":"$2}')"
        execmd "$cmd"
      else
        echo "====== More than one container ======"
        cimgs=$(docker image list --format 'table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | grep ${mandatory[0]})
        SIFS=$IFS
        IFS=$'\n'
        cimgs=($cimgs)
        IFS=$SIFS
        for ((i = 0; i < ${#cimgs[@]}; i++)); do
          echo "$i: ${cimgs[$i]}"
        done
        echo "-1: ALL"
        read -p "====== select one with number[0]: " diidx
        if [ -z $diidx ]; then
          diidx=0
        fi
        if [ $diidx -eq -1 ]; then
          cmd="docker rmi -f $(docker images | grep ${mandatory[0]} | awk '{print $1":"$2}')"
          execmd "$cmd"
        else
          cmd="docker rmi -f $(echo ${cimgs[$diidx]} | awk '{print $1":"$2}')"
          echo $cmd
          execmd "$cmd"
        fi
      fi
    else
      for ip in ${mandatory[@]:1}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dh" ] || [ "$subcmd" == "dhist" ]; then
    cmd="docker history ${mandatory[0]}"
    if [ ${#mandatory[@]} -eq 1 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]:1}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "da" ] || [ "$subcmd" == "daddr" ]; then
    cmd="docker inspect --format='{{json .NetworkSettings.Networks}}' ${mandatory[0]}"
    if [ ${#mandatory[@]} -eq 1 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]:1}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "de" ] || [ "$subcmd" == "denv" ]; then
    cmd="docker inspect --format='{{json .Config.Env}}' ${mandatory[0]}"
    if [ ${#mandatory[@]} -eq 1 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]:1}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dc" ] || [ "$subcmd" == "dcmd" ]; then
    cmd="docker inspect --format='{{json .Config.Cmd}}' ${mandatory[0]}"
    if [ ${#mandatory[@]} -eq 1 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]:1}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dp" ] || [ "$subcmd" == "dport" ]; then
    cmd="docker inspect --format='{{json .NetworkSettings.Ports}}' ${mandatory[0]}"
    if [ ${#mandatory[@]} -eq 1 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]:1}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "dm" ] || [ "$subcmd" == "dmnt" ]; then
    cmd="docker inspect --format='{{json .Mounts}}' ${mandatory[0]}"
    echo $cmd
    if [ ${#mandatory[@]} -eq 1 ]; then
      require docker
      execmd "$cmd"
    else
      for ip in ${mandatory[@]:1}; do
        execmd "$cmd" $ip
      done
    fi
  elif [ "$subcmd" == "cf" ] || [ "$subcmd" == "cfind" ]; then
    grep -nr "${mandatory[*]}"
  elif [ "$subcmd" == "df" ] || [ "$subcmd" == "dfind" ]; then
    require docker
    if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
      kwd="${mandatory[*]}"
    fi
    if [ -z "$kwd" ]; then
      echo "error: need arguments"
      exit 1
    fi

    items=$(docker ps -a --format 'table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' 2>/dev/null)
    SIFS=$IFS
    IFS=$'\n'
    items=($items)
    IFS=$SIFS

    for ((i = 1; i < ${#items[@]}; i++)); do
      lid=$(echo ${items[$i]} | awk '{print $1}')

      if [ $(docker inspect $lid | grep "$kwd" | wc -l) -gt 0 ]; then
        echo ${items[$i]}
      fi
    done
  elif [ "$subcmd" == "cfg" ] || [ "$subcmd" == "config" ]; then
    require kubectl
    kubectl $kc $context config view
  elif [ "$subcmd" == "dry" ] || [ "$subcmd" == "dryrun" ]; then
    require kubectl
    if [ "$ns" == "--all-namespaces" ]; then
      ns=""
    fi
    if [ ${#mandatory[@]} -gt 0 ]; then
      kubectl $kc $context ${mandatory[@]} --dry-run
    else
      echo "error: need arguments"
      exit 1
    fi
  elif [ "$subcmd" == "ap" ] || [ "$subcmd" == "apl" ] || [ "$subcmd" == "apply" ]; then
    require kubectl
    if [ "$ns" == "--all-namespaces" ]; then
      ns=""
    fi
    if [ ${#mandatory[@]} -gt 0 ]; then
      for fname in ${mandatory[@]}; do
        kubectl $kc $context apply -f $fname $ns
      done
    else
      echo "error: need arguments"
      exit 1
    fi
  elif [ "$subcmd" == "n" ] || [ "$subcmd" == "new" ] || [ "$subcmd" == "create" ]; then
    require kubectl
    if [ "$ns" == "--all-namespaces" ]; then
      ns=""
    fi
    if [ ${#mandatory[@]} -gt 0 ]; then
      isfile="true"
      for fname in ${mandatory[@]}; do
        if ! [[ $fname =~ .yaml$ ]] && ! [[ $fname =~ .yml$ ]] && ! [[ $fname =~ .json$ ]]; then
          isfile="false"
          break
        fi
      done
      if [ "$isfile" == "true" ]; then
        for fname in ${mandatory[@]}; do
          kubectl $kc $context create -f $fname $ns
        done
      else
        kubectl $kc $context create $kind ${mandatory[@]} $ns
      fi
    else
      echo "error: need arguments"
      exit 1
    fi
  elif [ "$subcmd" == "r" ] || [ "$subcmd" == "run" ]; then
    require kubectl
    if [ "$ns" == "--all-namespaces" ]; then
      ns=""
    fi
    if [ ${#mandatory[@]} -gt 1 ]; then
      kubectl $kc $context run ${mandatory[@]} $ns
    else
      echo "error: need arguments"
      exit 1
    fi
  elif [ "$subcmd" == "b" ] || [ "$subcmd" == "rbac" ]; then
    require kubectl rback dot
    if [ -n "$savedir" ]; then
      kubectl $kc $context get sa,roles,rolebindings,clusterroles,clusterrolebindings $ns -o json | rback -show-legend=false ${mandatory[*]} | dot -Tsvg >$savedir/rbac.svg
    else
      dispapp="xdg-open"
      if type display &>/dev/null; then
        dispapp="display"
      elif type inkview &>/dev/null; then
        dispapp="inkview"
      elif type feh &>/dev/null; then
        dispapp="feh --conversion-timeout 1"
      fi
      kubectl $kc $context get sa,roles,rolebindings,clusterroles,clusterrolebindings $ns -o json | rback -show-legend=false ${mandatory[*]} | dot -Tsvg | $dispapp
    fi
  elif [ "$subcmd" == "a" ] || [ "$subcmd" == "all" ]; then
    require kubectl
    kubectl $kc $context get all $ns
  elif [ "$subcmd" == "ro" ] || [ "$subcmd" == "rollout" ]; then
    require kubectl
    kubectl $kc $context rollout ${mandatory[@]} $ns
  elif [ "$subcmd" == "au" ] || [ "$subcmd" == "auth" ]; then
    require kubectl
    kubectl $kc $context auth "${mandatory[@]}" $ns
  elif [ "$subcmd" == "pr" ] || [ "$subcmd" == "proxy" ]; then
    require kubectl
    if [[ "${mandatory[*]}" =~ ":" ]]; then
      ip=$(echo "${mandatory[*]}" | awk -F ':' '{print $1}')
      pt=$(echo "${mandatory[*]}" | awk -F ':' '{print $2}')
      if [ -z "$ip" ]; then
        ip="127.0.0.1"
      fi
      if [ -z "$port" ]; then
        pt=$port
      fi
    else
      ip="127.0.0.1"
      pt=${mandatory[*]}
    fi
    kubectl $kc $context proxy --address $ip --port $pt
  elif [ "$subcmd" == "kf" ] || [ "$subcmd" == "kfind" ]; then
    require kubectl
    if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
      kwd="${mandatory[*]}"
    fi
    if [ -z "$kwd" ]; then
      echo "error: need arguments"
      exit 1
    fi

    items=$(kubectl $kc $context get $kind $ns 2>/dev/null)
    SIFS=$IFS
    IFS=$'\n'
    items=($items)
    IFS=$SIFS

    for ((i = 1; i < ${#items[@]}; i++)); do
      if [ "$ns" == "--all-namespaces" ]; then
        lns=$(echo ${items[$i]} | awk '{print $1}')
        lrs=$(echo ${items[$i]} | awk '{print $2}')
      else
        lns=$(echo "$ns" | awk '{print $2}')
        lrs=$(echo ${items[$i]} | awk '{print $1}')
      fi

      if [ $(kubectl $kc $context -n $lns get $kind $lrs -o yaml | grep "$kwd" | wc -l) -gt 0 ]; then
        echo -e "$lns\t$lrs"
      fi
    done
  else
    require kubectl
    if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
      # kwd=${mandatory[${#mandatory[@]} - 1]}
      # if [ ${#mandatory[@]} -gt 1 ]; then
      #   args=${mandatory[@]::${#mandatory[@]}-1}
      # fi
      kwd=${mandatory[0]}
      if [ ${#mandatory[@]} -gt 1 ]; then
        args=${mandatory[@]:1}
      fi
    elif [ -z "$kwd" ] && [ ${#mandatory[@]} -eq 0 ]; then
      case $subcmd in
      "g" | "get")
        kubectl $kc $context get $kind $ns
        ;;
      "s" | "desc" | "describe")
        kubectl $kc $context describe $kind $ns
        ;;
      "wa" | "watch")
        kubectl $kc $context get $kind $ns --watch
        ;;
      "w" | "wide")
        kubectl $kc $context get $kind $ns -o wide
        ;;
      "wl" | "wlabel")
        kubectl $kc $context get $kind $ns -o wide --show-labels
        ;;
      "y" | "yaml")
        kubectl $kc $context get $kind $ns -o yaml
        ;;
      "j" | "json")
        kubectl $kc $context get $kind $ns -o json
        ;;
      "tp" | "top")
        if [ "$ns" == "--all-namespaces" ]; then
          ns="-n default"
        fi
        if [ "$kind" == "pod" ] || [ "$kind" == "node" ]; then
          kubectl $kc $context top $kind $ns
        fi
        ;;
      esac
      exit 0
    elif [ -n "$kwd" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        args=${mandatory[@]}
      fi
    fi

    hasnsfield="false"
    ress=()
    result=$(kubectl $kc $context get $kind $ns 2>/dev/null)
    SIFS=$IFS
    IFS=$'\n'
    result=($result)
    IFS=$SIFS
    if [[ $(echo "${result[0]}" | awk '{print $1}') == "NAMESPACE" ]]; then
      hasnsfield="true"
    fi
    for ((i = 1; i < ${#result[@]}; i++)); do
      if [[ "${result[$i]}" =~ "$kwd" ]]; then
        ress+=("${result[$i]}")
      fi
    done
    #ress=($(echo ${result[@]:1} | grep "$kwd"))

    if [ $? -ne 0 ] || [ ${#ress[@]} -eq 0 ]; then
      echo "No $kind resources found with keyword $kwd"
      exit 1
    fi

    if [ ${#ress[@]} -eq 1 ]; then
      rs=$ress
    else
      echo "====== More than one $kind ======"
      for ((i = 0; i < ${#ress[@]}; i++)); do
        echo "$i: ${ress[$i]}"
      done
      # echo "====== Selected the first ======"
      read -p "====== select one with number[0]: " ridx
      if [ -z $ridx ]; then
        ridx=0
      fi
      rs=${ress[$ridx]}
    fi
    if [ "$ns" == "--all-namespaces" ]; then
      if [ "$hasnsfield" == "false" ]; then
        resname=$(echo $rs | awk '{print $1}')
      else
        resname=$(echo $rs | awk '{print $2}')
        namespace=$(echo $rs | awk '{print $1}')
        ns="-n $namespace"
      fi
    else
      resname=$(echo $rs | awk '{print $1}')
    fi

    if [ "$kind" == "pod" ]; then
      podinfo=$(kubectl $kc $context get pod $resname $ns -o=custom-columns=NODE:.spec.nodeName,HOST:.status.hostIP,NAME:.metadata.name,ADDR:.status.podIP,CNAME:.status.containerStatuses[$idx].name,CID:.status.containerStatuses[$idx].containerID 2>/dev/null | grep $resname)

      if [ $? -ne 0 ]; then
        echo "$resname[$idx] container not found"
        exit 1
      fi

      hname=$(echo $podinfo | awk '{print $1}')
      haddr=$(echo $podinfo | awk '{print $2}')
      pname=$(echo $podinfo | awk '{print $3}')
      caddr=$(echo $podinfo | awk '{print $4}')
      cname=$(echo $podinfo | awk '{print $5}')
      cid=$(echo $podinfo | awk '{print $6}')
      cid=${cid#*docker://}
      cid=${cid:0:12}

      echo "=================================================================================================================================================="
      echo "Namespace: "${ns#-n } "HostName: "$hname "HostIP:"$haddr "PodName:"$pname "PodIP:"$caddr "CName:"$cname "CID:"$cid
      echo "=================================================================================================================================================="

      if [ -n "$host" ]; then
        haddr=$host
      fi
    fi

    case $subcmd in
    "l" | "log")
      if [ "$kind" == "pod" ]; then
        if [ "$(hostname)" == "$hname" ] && type docker &>/dev/null; then
          docker logs $cid $amount
        else
          kubectl $kc $context logs $resname $cname $amount $ns
        fi
      else
        echo "subcmd log not fit for $kind"
      fi
      ;;
    "lf" | "logf")
      if [ $kind == "pod" ]; then
        if [ $(hostname) == "$hname" ] && type docker &>/dev/null; then
          docker logs -f $cid $amount
        else
          kubectl $kc $context logs -f $resname $cname $amount $ns
        fi
      else
        echo "subcmd logf not fit for $kind"
      fi
      ;;
    "i" | "insp" | "inspect")
      if [ "$kind" == "pod" ]; then
        if [ "$(hostname)" == "$hname" ] && type docker &>/dev/null; then
          docker inspect $cid
        else
          execmd "docker inspect $cid" $haddr
        fi
      else
        echo "subcmd inspect not fit for $kind"
      fi
      ;;
    "g" | "get")
      kubectl $kc $context get $kind $ns
      ;;
    "s" | "desc" | "describe")
      kubectl $kc $context describe $kind $resname $ns
      ;;
    "wa" | "watch")
      kubectl $kc $context get $kind $resname $ns --watch
      ;;
    "w" | "wide")
      kubectl $kc $context get $kind $resname $ns -o wide
      ;;
    "wl" | "wlabel")
      kubectl $kc $context get $kind $resname $ns -o wide --show-labels
      ;;
    "y" | "yaml")
      kubectl $kc $context get $kind $resname $ns -o yaml
      ;;
    "j" | "json")
      kubectl $kc $context get $kind $resname $ns -o json
      ;;
    "tp" | "top")
      if [ "$ns" == "--all-namespaces" ]; then
        ns="-n default"
      fi
      if [ "$kind" == "pod" ] || [ "$kind" == "node" ]; then
        kubectl $kc $context top $kind $resname $ns
      fi
      ;;
    "p" | "patch")
      kubectl $kc $context patch $kind $resname $ns --patch $args
      ;;
    "rm" | "del" | "delete")
      isfile="true"
      for fname in ${mandatory[@]}; do
        if ! [[ $fname =~ .yaml$ ]] && ! [[ $fname =~ .yml$ ]] && ! [[ $fname =~ .json$ ]]; then
          isfile="false"
          break
        fi
      done
      if [ "$isfile" == "true" ]; then
        for fname in ${mandatory[@]}; do
          kubectl $kc $context delete -f $fname
        done
      else
        kubectl $kc $context delete $kind $resname $ns
      fi
      ;;
    "e" | "exe" | "exec")
      if [ "$kind" == "pod" ]; then
        kubectl $kc $context exec $resname -c $cname $args $ns
      else
        echo "subcmd exec not fit for $kind"
      fi
      ;;
    "ie" | "iexe" | "iexec")
      if [ $kind == "pod" ]; then
        kubectl $kc $context exec -it $resname -c $cname sh $ns
      else
        echo "subcmd iexec not fit for $kind"
      fi
      ;;
    "at" | "attach")
      if [ "$kind" == "pod" ]; then
        kubectl $kc $context attach $resname -c $cname $ns
      else
        echo "subcmd attach not fit for $kind"
      fi
      ;;
    "cp" | "copy")
      if [ "$kind" == "pod" ]; then
        prearg=$(echo "$args" | awk -F ':' '{print $1}')
        sufarg=$(echo "$args" | awk -F ':' '{print $2}')
        if [ "$prearg" == "" ]; then
          prearg="$resname:"$prearg
        else
          sufarg="$resname:"$sufarg
        fi
        kubectl $kc $context cp $prearg$sufarg $ns
      else
        echo "subcmd copy not fit for $kind"
      fi
      ;;
    "pf" | "forward" | "port-forward")
      if [ "$kind" == "pod" ]; then
        kubectl $kc $context port-forward $resname $args $ns
      else
        echo "subcmd port-forward not fit for $kind"
      fi
      ;;
    "x" | "deb" | "debug")
      if [ "$kind" == "pod" ]; then
        if [ "$image" == "xo" ] || [ "$image" == "xshrim/xo" ]; then
          imgsh="$image zsh $chroot"
        else
          imgsh="$image sh $chroot"
        fi

        cmd="docker run --rm -it $vol --network=container:$cid --pid=container:$cid --ipc=container:$cid $imgsh"

        execmd "$cmd" $haddr
      else
        echo "subcmd debug not fit for $kind"
      fi
      ;;
    *)
      usage
      exit 1
      ;;
    esac
  fi
fi
